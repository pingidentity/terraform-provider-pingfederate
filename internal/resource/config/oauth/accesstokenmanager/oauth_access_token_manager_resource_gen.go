// Code generated by ping-terraform-plugin-framework-generator

package oauthaccesstokenmanager

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	client "github.com/pingidentity/pingfederate-go-client/v1210/configurationapi"
	"github.com/pingidentity/terraform-provider-pingfederate/internal/resource/common/id"
	"github.com/pingidentity/terraform-provider-pingfederate/internal/resource/common/importprivatestate"
	"github.com/pingidentity/terraform-provider-pingfederate/internal/resource/common/pluginconfiguration"
	"github.com/pingidentity/terraform-provider-pingfederate/internal/resource/config"
	"github.com/pingidentity/terraform-provider-pingfederate/internal/resource/configvalidators"
	internaltypes "github.com/pingidentity/terraform-provider-pingfederate/internal/types"
	"github.com/pingidentity/terraform-provider-pingfederate/internal/version"
)

var (
	_ resource.Resource                = &oauthAccessTokenManagerResource{}
	_ resource.ResourceWithConfigure   = &oauthAccessTokenManagerResource{}
	_ resource.ResourceWithImportState = &oauthAccessTokenManagerResource{}
)

func OauthAccessTokenManagerResource() resource.Resource {
	return &oauthAccessTokenManagerResource{}
}

type oauthAccessTokenManagerResource struct {
	providerConfig internaltypes.ProviderConfiguration
	apiClient      *client.APIClient
}

func (r *oauthAccessTokenManagerResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_oauth_access_token_manager"
}

func (r *oauthAccessTokenManagerResource) Configure(_ context.Context, req resource.ConfigureRequest, _ *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerCfg := req.ProviderData.(internaltypes.ResourceConfiguration)
	r.providerConfig = providerCfg.ProviderConfig
	r.apiClient = providerCfg.ApiClient
}

type oauthAccessTokenManagerResourceModel struct {
	AccessControlSettings          types.Object `tfsdk:"access_control_settings"`
	AttributeContract              types.Object `tfsdk:"attribute_contract"`
	Configuration                  types.Object `tfsdk:"configuration"`
	Id                             types.String `tfsdk:"id"`
	ManagerId                      types.String `tfsdk:"manager_id"`
	Name                           types.String `tfsdk:"name"`
	ParentRef                      types.Object `tfsdk:"parent_ref"`
	PluginDescriptorRef            types.Object `tfsdk:"plugin_descriptor_ref"`
	SelectionSettings              types.Object `tfsdk:"selection_settings"`
	SequenceNumber                 types.Int64  `tfsdk:"sequence_number"`
	SessionValidationSettings      types.Object `tfsdk:"session_validation_settings"`
	TokenEndpointAttributeContract types.Object `tfsdk:"token_endpoint_attribute_contract"`
}

func (r *oauthAccessTokenManagerResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	// access_control_settings.allowed_clients default
	accessControlSettingsAllowedClientsAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	accessControlSettingsAllowedClientsElementType := types.ObjectType{AttrTypes: accessControlSettingsAllowedClientsAttrTypes}
	accessControlSettingsAllowedClientsDefault, diags := types.ListValue(accessControlSettingsAllowedClientsElementType, nil)
	resp.Diagnostics.Append(diags...)
	// selection_settings.resource_uris default
	selectionSettingsResourceUrisDefault, diags := types.SetValue(types.StringType, nil)
	resp.Diagnostics.Append(diags...)
	// token_endpoint_attribute_contract.attributes default
	tokenEndpointAttributeContractAttributesAttrTypes := map[string]attr.Type{
		"mapped_scopes": types.SetType{ElemType: types.StringType},
		"multi_valued":  types.BoolType,
		"name":          types.StringType,
	}
	tokenEndpointAttributeContractAttributesElementType := types.ObjectType{AttrTypes: tokenEndpointAttributeContractAttributesAttrTypes}
	tokenEndpointAttributeContractAttributesDefault, diags := types.SetValue(tokenEndpointAttributeContractAttributesElementType, nil)
	resp.Diagnostics.Append(diags...)
	// token_endpoint_attribute_contract.attributes.mapped_scopes default
	tokenEndpointAttributeContractAttributesMappedScopesDefault, diags := types.SetValue(types.StringType, nil)
	resp.Diagnostics.Append(diags...)

	resp.Schema = schema.Schema{
		Description: "Resource to create and manage an OAuth access token manager plugin instance.",
		Attributes: map[string]schema.Attribute{
			"access_control_settings": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"allowed_clients": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Required:    true,
									Description: "The ID of the resource.",
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(1),
									},
								},
							},
						},
						Optional:    true,
						Computed:    true,
						Description: "If `restrict_clients` is `true`, this field defines the list of OAuth clients that are allowed to access the token manager.",
						Default:     listdefault.StaticValue(accessControlSettingsAllowedClientsDefault),
					},
					"restrict_clients": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: "Determines whether access to this token manager is restricted to specific OAuth clients. If `false`, the `allowed_clients` field is ignored. The default value is `false`.",
					},
				},
				Computed:    true,
				Optional:    true,
				Default:     objectdefault.StaticValue(accessControlSettingsDefault),
				Description: "Settings which determine which clients may access this token manager.",
			},
			"attribute_contract": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"core_attributes": schema.SetNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Description: "The name of this attribute.",
									Computed:    true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
								"multi_valued": schema.BoolAttribute{
									Description: "Indicates whether attribute value is always returned as an array.",
									Computed:    true,
									PlanModifiers: []planmodifier.Bool{
										boolplanmodifier.UseStateForUnknown(),
									},
								},
							},
						},
						Computed:    true,
						Description: "A list of core token attributes that are associated with the access token management plugin type. This field is read-only.",
						PlanModifiers: []planmodifier.Set{
							setplanmodifier.UseStateForUnknown(),
						},
					},
					"default_subject_attribute": schema.StringAttribute{
						Optional:    true,
						Description: "Default subject attribute to use for audit logging when validating the access token. Blank value means to use `USER_KEY` attribute value after grant lookup.",
						Validators: []validator.String{
							stringvalidator.LengthAtLeast(1),
						},
					},
					"extended_attributes": schema.SetNestedAttribute{
						Description: "A list of additional token attributes that are associated with this access token management plugin instance.",
						Required:    true,
						Validators: []validator.Set{
							setvalidator.SizeAtLeast(1),
						},
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Description: "The name of this attribute.",
									Required:    true,
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(1),
									},
								},
								"multi_valued": schema.BoolAttribute{
									Description: "Indicates whether attribute value is always returned as an array. The default is `false`.",
									Computed:    true,
									Optional:    true,
									Default:     booldefault.StaticBool(false),
								},
							},
						},
					},
				},
				Required:    true,
				Description: "The list of attributes that will be added to an access token.",
			},
			"configuration": pluginconfiguration.ToSchema(),
			"manager_id": schema.StringAttribute{
				Required:    true,
				Description: "The ID of the plugin instance. The ID cannot be modified once the instance is created. Must be alphanumeric, contain no spaces, and be less than 33 characters. This field is immutable and will trigger a replacement plan if changed.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1),
					stringvalidator.LengthAtMost(32),
					configvalidators.IsAlphanumeric(),
				},
			},
			"name": schema.StringAttribute{
				Required:    true,
				Description: "The plugin instance name. The name can be modified once the instance is created.",
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1),
				},
			},
			"parent_ref": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						Required:    true,
						Description: "The ID of the resource.",
						Validators: []validator.String{
							stringvalidator.LengthAtLeast(1),
						},
					},
				},
				Optional:    true,
				Description: "The reference to this plugin's parent instance. The parent reference is only accepted if the plugin type supports parent instances. Note: This parent reference is required if this plugin instance is used as an overriding plugin (e.g. connection adapter overrides)",
			},
			"plugin_descriptor_ref": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						Required:    true,
						Description: "The ID of the resource. This field is immutable and will trigger a replacement plan if changed.",
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
						Validators: []validator.String{
							stringvalidator.LengthAtLeast(1),
						},
					},
				},
				Required:    true,
				Description: "Reference to the plugin descriptor for this instance. This field is immutable and will trigger a replacement plan if changed.",
			},
			"selection_settings": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"resource_uris": schema.SetAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
						Description: "The list of base resource URI's which map to this token manager. A resource URI, specified via the 'aud' parameter, can be used to select a specific token manager for an OAuth request.",
						Default:     setdefault.StaticValue(selectionSettingsResourceUrisDefault),
					},
				},
				Computed:    true,
				Optional:    true,
				Default:     objectdefault.StaticValue(selectionSettingsDefault),
				Description: "Settings which determine how this token manager can be selected for use by an OAuth request.",
			},
			"sequence_number": schema.Int64Attribute{
				Computed:    true,
				Description: "Number added to an access token to identify which Access Token Manager issued the token.",
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"session_validation_settings": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"include_session_id": schema.BoolAttribute{
						Description: "Include the session identifier in the access token. Note that if any of the session validation features is enabled, the session identifier will already be included in the access tokens. The default is `false`.",
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
					},
					"check_valid_authn_session": schema.BoolAttribute{
						Description: "Check for a valid authentication session when validating the access token. The default is `false`.",
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
					},
					"check_session_revocation_status": schema.BoolAttribute{
						Description: "Check the session revocation status when validating the access token. The default is `false`.",
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
					},
					"update_authn_session_activity": schema.BoolAttribute{
						Description: "Update authentication session activity when validating the access token. The default is `false`.",
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
					},
				},
				Computed:    true,
				Optional:    true,
				Default:     objectdefault.StaticValue(sessionValidationSettingsDefault),
				Description: "Settings which determine how the user session is associated with the access token.",
			},
			"token_endpoint_attribute_contract": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"attributes": schema.SetNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"mapped_scopes": schema.SetAttribute{
									ElementType: types.StringType,
									Optional:    true,
									Computed:    true,
									Description: "List of scopes that will trigger this attribute to be included in the token endpoint response.",
									Default:     setdefault.StaticValue(tokenEndpointAttributeContractAttributesMappedScopesDefault),
								},
								"multi_valued": schema.BoolAttribute{
									Optional:    true,
									Description: "Indicates whether attribute value is always returned as an array.",
								},
								"name": schema.StringAttribute{
									Required:    true,
									Description: "The name of this attribute.",
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(1),
									},
								},
							},
						},
						Optional:    true,
						Computed:    true,
						Description: "A list of token endpoint response attributes that are associated with this access token management plugin instance.",
						Default:     setdefault.StaticValue(tokenEndpointAttributeContractAttributesDefault),
					},
				},
				Optional:    true,
				Computed:    true,
				Description: "A set of attributes exposed by an Access Token Manager in a token endpoint response. Supported in PingFederate `12.2.0` and later.",
			},
		},
	}
	id.ToSchema(&resp.Schema)
}

func (r *oauthAccessTokenManagerResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	// Compare to version 12.2.0 of PF
	compare, err := version.Compare(r.providerConfig.ProductVersion, version.PingFederate1220)
	if err != nil {
		resp.Diagnostics.AddError("Failed to compare PingFederate versions", err.Error())
		return
	}
	pfVersionAtLeast1220 := compare >= 0
	var plan *oauthAccessTokenManagerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if plan == nil {
		return
	}
	// If any of these fields are set by the user and the PF version is not new enough, throw an error
	tokenEndpointAttributeContractAttributesAttrTypes := map[string]attr.Type{
		"mapped_scopes": types.SetType{ElemType: types.StringType},
		"multi_valued":  types.BoolType,
		"name":          types.StringType,
	}
	tokenEndpointAttributeContractAttributesElementType := types.ObjectType{AttrTypes: tokenEndpointAttributeContractAttributesAttrTypes}
	tokenEndpointAttributeContractAttrTypes := map[string]attr.Type{
		"attributes": types.SetType{ElemType: tokenEndpointAttributeContractAttributesElementType},
	}
	var respDiags diag.Diagnostics
	planModified := false
	if !pfVersionAtLeast1220 {
		if internaltypes.IsDefined(plan.TokenEndpointAttributeContract) {
			version.AddUnsupportedAttributeError("token_endpoint_attribute_contract",
				r.providerConfig.ProductVersion, version.PingFederate1220, &resp.Diagnostics)
		} else if plan.TokenEndpointAttributeContract.IsUnknown() {
			plan.TokenEndpointAttributeContract = types.ObjectNull(tokenEndpointAttributeContractAttrTypes)
			planModified = true
		}
	} else if plan.TokenEndpointAttributeContract.IsUnknown() {
		// Set default if the version is new enough
		tokenEndpointAttributeContractAttributesDefault, respDiags := types.SetValue(tokenEndpointAttributeContractAttributesElementType, nil)
		resp.Diagnostics.Append(respDiags...)
		plan.TokenEndpointAttributeContract, respDiags = types.ObjectValue(tokenEndpointAttributeContractAttrTypes, map[string]attr.Value{
			"attributes": tokenEndpointAttributeContractAttributesDefault,
		})
		resp.Diagnostics.Append(respDiags...)
		planModified = true
	}
	if planModified {
		resp.Diagnostics.Append(resp.Plan.Set(ctx, plan)...)
	}
	var state *oauthAccessTokenManagerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if state == nil {
		return
	}
	plan.Configuration, respDiags = pluginconfiguration.MarkComputedAttrsUnknownOnChange(plan.Configuration, state.Configuration)
	resp.Diagnostics.Append(respDiags...)
	resp.Diagnostics.Append(resp.Plan.Set(ctx, plan)...)
}

func (model *oauthAccessTokenManagerResourceModel) buildClientStruct() (*client.AccessTokenManager, diag.Diagnostics) {
	result := &client.AccessTokenManager{}
	var respDiags diag.Diagnostics
	var err error
	// access_control_settings
	if !model.AccessControlSettings.IsNull() {
		accessControlSettingsValue := &client.AtmAccessControlSettings{}
		accessControlSettingsAttrs := model.AccessControlSettings.Attributes()
		accessControlSettingsValue.AllowedClients = []client.ResourceLink{}
		for _, allowedClientsElement := range accessControlSettingsAttrs["allowed_clients"].(types.List).Elements() {
			allowedClientsValue := client.ResourceLink{}
			allowedClientsAttrs := allowedClientsElement.(types.Object).Attributes()
			allowedClientsValue.Id = allowedClientsAttrs["id"].(types.String).ValueString()
			accessControlSettingsValue.AllowedClients = append(accessControlSettingsValue.AllowedClients, allowedClientsValue)
		}
		accessControlSettingsValue.RestrictClients = accessControlSettingsAttrs["restrict_clients"].(types.Bool).ValueBoolPointer()
		result.AccessControlSettings = accessControlSettingsValue
	}

	// attribute_contract
	if !model.AttributeContract.IsNull() {
		attributeContractValue := &client.AccessTokenAttributeContract{}
		attributeContractAttrs := model.AttributeContract.Attributes()
		attributeContractValue.CoreAttributes = []client.AccessTokenAttribute{}
		for _, coreAttributesElement := range attributeContractAttrs["core_attributes"].(types.Set).Elements() {
			coreAttributesValue := client.AccessTokenAttribute{}
			coreAttributesAttrs := coreAttributesElement.(types.Object).Attributes()
			coreAttributesValue.MultiValued = coreAttributesAttrs["multi_valued"].(types.Bool).ValueBoolPointer()
			coreAttributesValue.Name = coreAttributesAttrs["name"].(types.String).ValueString()
			attributeContractValue.CoreAttributes = append(attributeContractValue.CoreAttributes, coreAttributesValue)
		}
		attributeContractValue.DefaultSubjectAttribute = attributeContractAttrs["default_subject_attribute"].(types.String).ValueStringPointer()
		attributeContractValue.ExtendedAttributes = []client.AccessTokenAttribute{}
		for _, extendedAttributesElement := range attributeContractAttrs["extended_attributes"].(types.Set).Elements() {
			extendedAttributesValue := client.AccessTokenAttribute{}
			extendedAttributesAttrs := extendedAttributesElement.(types.Object).Attributes()
			extendedAttributesValue.MultiValued = extendedAttributesAttrs["multi_valued"].(types.Bool).ValueBoolPointer()
			extendedAttributesValue.Name = extendedAttributesAttrs["name"].(types.String).ValueString()
			attributeContractValue.ExtendedAttributes = append(attributeContractValue.ExtendedAttributes, extendedAttributesValue)
		}
		result.AttributeContract = attributeContractValue
	}

	// configuration
	configurationValue, err := pluginconfiguration.ClientStruct(model.Configuration)
	if err != nil {
		respDiags.AddError("Error building client struct for configuration", err.Error())
	} else {
		result.Configuration = *configurationValue
	}

	// manager_id
	result.Id = model.ManagerId.ValueString()
	// name
	result.Name = model.Name.ValueString()
	// parent_ref
	if !model.ParentRef.IsNull() {
		parentRefValue := &client.ResourceLink{}
		parentRefAttrs := model.ParentRef.Attributes()
		parentRefValue.Id = parentRefAttrs["id"].(types.String).ValueString()
		result.ParentRef = parentRefValue
	}

	// plugin_descriptor_ref
	pluginDescriptorRefValue := client.ResourceLink{}
	pluginDescriptorRefAttrs := model.PluginDescriptorRef.Attributes()
	pluginDescriptorRefValue.Id = pluginDescriptorRefAttrs["id"].(types.String).ValueString()
	result.PluginDescriptorRef = pluginDescriptorRefValue

	// selection_settings
	if !model.SelectionSettings.IsNull() {
		selectionSettingsValue := &client.AtmSelectionSettings{}
		selectionSettingsAttrs := model.SelectionSettings.Attributes()
		if !selectionSettingsAttrs["resource_uris"].IsNull() {
			selectionSettingsValue.ResourceUris = []string{}
			for _, resourceUrisElement := range selectionSettingsAttrs["resource_uris"].(types.Set).Elements() {
				selectionSettingsValue.ResourceUris = append(selectionSettingsValue.ResourceUris, resourceUrisElement.(types.String).ValueString())
			}
		}
		result.SelectionSettings = selectionSettingsValue
	}

	// sequence_number
	if !model.SequenceNumber.IsUnknown() {
		result.SequenceNumber = model.SequenceNumber.ValueInt64Pointer()
	}
	// session_validation_settings
	if !model.SessionValidationSettings.IsNull() {
		sessionValidationSettingsValue := &client.SessionValidationSettings{}
		sessionValidationSettingsAttrs := model.SessionValidationSettings.Attributes()
		sessionValidationSettingsValue.CheckSessionRevocationStatus = sessionValidationSettingsAttrs["check_session_revocation_status"].(types.Bool).ValueBoolPointer()
		sessionValidationSettingsValue.CheckValidAuthnSession = sessionValidationSettingsAttrs["check_valid_authn_session"].(types.Bool).ValueBoolPointer()
		sessionValidationSettingsValue.IncludeSessionId = sessionValidationSettingsAttrs["include_session_id"].(types.Bool).ValueBoolPointer()
		sessionValidationSettingsValue.UpdateAuthnSessionActivity = sessionValidationSettingsAttrs["update_authn_session_activity"].(types.Bool).ValueBoolPointer()
		result.SessionValidationSettings = sessionValidationSettingsValue
	}

	// token_endpoint_attribute_contract
	if !model.TokenEndpointAttributeContract.IsNull() {
		tokenEndpointAttributeContractValue := &client.TokenEndpointAttributeContract{}
		tokenEndpointAttributeContractAttrs := model.TokenEndpointAttributeContract.Attributes()
		tokenEndpointAttributeContractValue.Attributes = []client.TokenEndpointAttribute{}
		for _, attributesElement := range tokenEndpointAttributeContractAttrs["attributes"].(types.Set).Elements() {
			attributesValue := client.TokenEndpointAttribute{}
			attributesAttrs := attributesElement.(types.Object).Attributes()
			if !attributesAttrs["mapped_scopes"].IsNull() {
				attributesValue.MappedScopes = []string{}
				for _, mappedScopesElement := range attributesAttrs["mapped_scopes"].(types.Set).Elements() {
					attributesValue.MappedScopes = append(attributesValue.MappedScopes, mappedScopesElement.(types.String).ValueString())
				}
			}
			attributesValue.MultiValued = attributesAttrs["multi_valued"].(types.Bool).ValueBoolPointer()
			attributesValue.Name = attributesAttrs["name"].(types.String).ValueString()
			tokenEndpointAttributeContractValue.Attributes = append(tokenEndpointAttributeContractValue.Attributes, attributesValue)
		}
		result.TokenEndpointAttributeContract = tokenEndpointAttributeContractValue
	}

	return result, respDiags
}

func (state *oauthAccessTokenManagerResourceModel) readClientResponse(response *client.AccessTokenManager, isImportRead bool) diag.Diagnostics {
	var respDiags, diags diag.Diagnostics
	// access_control_settings
	accessControlSettingsAllowedClientsAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	accessControlSettingsAllowedClientsElementType := types.ObjectType{AttrTypes: accessControlSettingsAllowedClientsAttrTypes}
	accessControlSettingsAttrTypes := map[string]attr.Type{
		"allowed_clients":  types.ListType{ElemType: accessControlSettingsAllowedClientsElementType},
		"restrict_clients": types.BoolType,
	}
	var accessControlSettingsValue types.Object
	if response.AccessControlSettings == nil {
		accessControlSettingsValue = types.ObjectNull(accessControlSettingsAttrTypes)
	} else {
		var accessControlSettingsAllowedClientsValues []attr.Value
		for _, accessControlSettingsAllowedClientsResponseValue := range response.AccessControlSettings.AllowedClients {
			accessControlSettingsAllowedClientsValue, diags := types.ObjectValue(accessControlSettingsAllowedClientsAttrTypes, map[string]attr.Value{
				"id": types.StringValue(accessControlSettingsAllowedClientsResponseValue.Id),
			})
			respDiags.Append(diags...)
			accessControlSettingsAllowedClientsValues = append(accessControlSettingsAllowedClientsValues, accessControlSettingsAllowedClientsValue)
		}
		accessControlSettingsAllowedClientsValue, diags := types.ListValue(accessControlSettingsAllowedClientsElementType, accessControlSettingsAllowedClientsValues)
		respDiags.Append(diags...)
		accessControlSettingsValue, diags = types.ObjectValue(accessControlSettingsAttrTypes, map[string]attr.Value{
			"allowed_clients":  accessControlSettingsAllowedClientsValue,
			"restrict_clients": types.BoolPointerValue(response.AccessControlSettings.RestrictClients),
		})
		respDiags.Append(diags...)
	}

	state.AccessControlSettings = accessControlSettingsValue
	// attribute_contract
	attributeContractCoreAttributesAttrTypes := map[string]attr.Type{
		"multi_valued": types.BoolType,
		"name":         types.StringType,
	}
	attributeContractCoreAttributesElementType := types.ObjectType{AttrTypes: attributeContractCoreAttributesAttrTypes}
	attributeContractExtendedAttributesAttrTypes := map[string]attr.Type{
		"multi_valued": types.BoolType,
		"name":         types.StringType,
	}
	attributeContractExtendedAttributesElementType := types.ObjectType{AttrTypes: attributeContractExtendedAttributesAttrTypes}
	attributeContractAttrTypes := map[string]attr.Type{
		"core_attributes":           types.SetType{ElemType: attributeContractCoreAttributesElementType},
		"default_subject_attribute": types.StringType,
		"extended_attributes":       types.SetType{ElemType: attributeContractExtendedAttributesElementType},
	}
	var attributeContractValue types.Object
	if response.AttributeContract == nil {
		attributeContractValue = types.ObjectNull(attributeContractAttrTypes)
	} else {
		var attributeContractCoreAttributesValues []attr.Value
		for _, attributeContractCoreAttributesResponseValue := range response.AttributeContract.CoreAttributes {
			attributeContractCoreAttributesValue, diags := types.ObjectValue(attributeContractCoreAttributesAttrTypes, map[string]attr.Value{
				"multi_valued": types.BoolPointerValue(attributeContractCoreAttributesResponseValue.MultiValued),
				"name":         types.StringValue(attributeContractCoreAttributesResponseValue.Name),
			})
			respDiags.Append(diags...)
			attributeContractCoreAttributesValues = append(attributeContractCoreAttributesValues, attributeContractCoreAttributesValue)
		}
		attributeContractCoreAttributesValue, diags := types.SetValue(attributeContractCoreAttributesElementType, attributeContractCoreAttributesValues)
		respDiags.Append(diags...)
		var attributeContractExtendedAttributesValues []attr.Value
		for _, attributeContractExtendedAttributesResponseValue := range response.AttributeContract.ExtendedAttributes {
			attributeContractExtendedAttributesValue, diags := types.ObjectValue(attributeContractExtendedAttributesAttrTypes, map[string]attr.Value{
				"multi_valued": types.BoolPointerValue(attributeContractExtendedAttributesResponseValue.MultiValued),
				"name":         types.StringValue(attributeContractExtendedAttributesResponseValue.Name),
			})
			respDiags.Append(diags...)
			attributeContractExtendedAttributesValues = append(attributeContractExtendedAttributesValues, attributeContractExtendedAttributesValue)
		}
		attributeContractExtendedAttributesValue, diags := types.SetValue(attributeContractExtendedAttributesElementType, attributeContractExtendedAttributesValues)
		respDiags.Append(diags...)
		attributeContractValue, diags = types.ObjectValue(attributeContractAttrTypes, map[string]attr.Value{
			"core_attributes":           attributeContractCoreAttributesValue,
			"default_subject_attribute": types.StringPointerValue(response.AttributeContract.DefaultSubjectAttribute),
			"extended_attributes":       attributeContractExtendedAttributesValue,
		})
		respDiags.Append(diags...)
	}

	state.AttributeContract = attributeContractValue
	// configuration
	configurationValue, diags := pluginconfiguration.ToState(state.Configuration, &response.Configuration, isImportRead)
	respDiags.Append(diags...)

	state.Configuration = configurationValue
	// id
	state.Id = types.StringValue(response.Id)
	// manager_id
	state.ManagerId = types.StringValue(response.Id)
	// name
	state.Name = types.StringValue(response.Name)
	// parent_ref
	parentRefAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	var parentRefValue types.Object
	if response.ParentRef == nil {
		parentRefValue = types.ObjectNull(parentRefAttrTypes)
	} else {
		parentRefValue, diags = types.ObjectValue(parentRefAttrTypes, map[string]attr.Value{
			"id": types.StringValue(response.ParentRef.Id),
		})
		respDiags.Append(diags...)
	}

	state.ParentRef = parentRefValue
	// plugin_descriptor_ref
	pluginDescriptorRefAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	pluginDescriptorRefValue, diags := types.ObjectValue(pluginDescriptorRefAttrTypes, map[string]attr.Value{
		"id": types.StringValue(response.PluginDescriptorRef.Id),
	})
	respDiags.Append(diags...)

	state.PluginDescriptorRef = pluginDescriptorRefValue
	// selection_settings
	selectionSettingsAttrTypes := map[string]attr.Type{
		"resource_uris": types.SetType{ElemType: types.StringType},
	}
	var selectionSettingsValue types.Object
	if response.SelectionSettings == nil {
		selectionSettingsValue = types.ObjectNull(selectionSettingsAttrTypes)
	} else {
		selectionSettingsResourceUrisValue, diags := types.SetValueFrom(context.Background(), types.StringType, response.SelectionSettings.ResourceUris)
		respDiags.Append(diags...)
		selectionSettingsValue, diags = types.ObjectValue(selectionSettingsAttrTypes, map[string]attr.Value{
			"resource_uris": selectionSettingsResourceUrisValue,
		})
		respDiags.Append(diags...)
	}

	state.SelectionSettings = selectionSettingsValue
	// sequence_number
	state.SequenceNumber = types.Int64PointerValue(response.SequenceNumber)
	// session_validation_settings
	sessionValidationSettingsAttrTypes := map[string]attr.Type{
		"check_session_revocation_status": types.BoolType,
		"check_valid_authn_session":       types.BoolType,
		"include_session_id":              types.BoolType,
		"update_authn_session_activity":   types.BoolType,
	}
	var sessionValidationSettingsValue types.Object
	if response.SessionValidationSettings == nil {
		sessionValidationSettingsValue = types.ObjectNull(sessionValidationSettingsAttrTypes)
	} else {
		sessionValidationSettingsValue, diags = types.ObjectValue(sessionValidationSettingsAttrTypes, map[string]attr.Value{
			"check_session_revocation_status": types.BoolPointerValue(response.SessionValidationSettings.CheckSessionRevocationStatus),
			"check_valid_authn_session":       types.BoolPointerValue(response.SessionValidationSettings.CheckValidAuthnSession),
			"include_session_id":              types.BoolPointerValue(response.SessionValidationSettings.IncludeSessionId),
			"update_authn_session_activity":   types.BoolPointerValue(response.SessionValidationSettings.UpdateAuthnSessionActivity),
		})
		respDiags.Append(diags...)
	}

	state.SessionValidationSettings = sessionValidationSettingsValue
	// token_endpoint_attribute_contract
	tokenEndpointAttributeContractAttributesAttrTypes := map[string]attr.Type{
		"mapped_scopes": types.SetType{ElemType: types.StringType},
		"multi_valued":  types.BoolType,
		"name":          types.StringType,
	}
	tokenEndpointAttributeContractAttributesElementType := types.ObjectType{AttrTypes: tokenEndpointAttributeContractAttributesAttrTypes}
	tokenEndpointAttributeContractAttrTypes := map[string]attr.Type{
		"attributes": types.SetType{ElemType: tokenEndpointAttributeContractAttributesElementType},
	}
	var tokenEndpointAttributeContractValue types.Object
	if response.TokenEndpointAttributeContract == nil {
		tokenEndpointAttributeContractValue = types.ObjectNull(tokenEndpointAttributeContractAttrTypes)
	} else {
		var tokenEndpointAttributeContractAttributesValues []attr.Value
		for _, tokenEndpointAttributeContractAttributesResponseValue := range response.TokenEndpointAttributeContract.Attributes {
			tokenEndpointAttributeContractAttributesMappedScopesValue, diags := types.SetValueFrom(context.Background(), types.StringType, tokenEndpointAttributeContractAttributesResponseValue.MappedScopes)
			respDiags.Append(diags...)
			tokenEndpointAttributeContractAttributesValue, diags := types.ObjectValue(tokenEndpointAttributeContractAttributesAttrTypes, map[string]attr.Value{
				"mapped_scopes": tokenEndpointAttributeContractAttributesMappedScopesValue,
				"multi_valued":  types.BoolPointerValue(tokenEndpointAttributeContractAttributesResponseValue.MultiValued),
				"name":          types.StringValue(tokenEndpointAttributeContractAttributesResponseValue.Name),
			})
			respDiags.Append(diags...)
			tokenEndpointAttributeContractAttributesValues = append(tokenEndpointAttributeContractAttributesValues, tokenEndpointAttributeContractAttributesValue)
		}
		tokenEndpointAttributeContractAttributesValue, diags := types.SetValue(tokenEndpointAttributeContractAttributesElementType, tokenEndpointAttributeContractAttributesValues)
		respDiags.Append(diags...)
		tokenEndpointAttributeContractValue, diags = types.ObjectValue(tokenEndpointAttributeContractAttrTypes, map[string]attr.Value{
			"attributes": tokenEndpointAttributeContractAttributesValue,
		})
		respDiags.Append(diags...)
	}

	state.TokenEndpointAttributeContract = tokenEndpointAttributeContractValue
	return respDiags
}

func (r *oauthAccessTokenManagerResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data oauthAccessTokenManagerResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Create API call logic
	clientData, diags := data.buildClientStruct()
	resp.Diagnostics.Append(diags...)
	apiCreateRequest := r.apiClient.OauthAccessTokenManagersAPI.CreateTokenManager(config.AuthContext(ctx, r.providerConfig))
	apiCreateRequest = apiCreateRequest.Body(*clientData)
	responseData, httpResp, err := r.apiClient.OauthAccessTokenManagersAPI.CreateTokenManagerExecute(apiCreateRequest)
	if err != nil {
		config.ReportHttpError(ctx, &resp.Diagnostics, "An error occurred while creating the oauthAccessTokenManager", err, httpResp)
		return
	}

	// Read response into the model
	resp.Diagnostics.Append(data.readClientResponse(responseData, false)...)

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *oauthAccessTokenManagerResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	isImportRead, diags := importprivatestate.IsImportRead(ctx, req, resp)
	resp.Diagnostics.Append(diags...)

	var data oauthAccessTokenManagerResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Read API call logic
	responseData, httpResp, err := r.apiClient.OauthAccessTokenManagersAPI.GetTokenManager(config.AuthContext(ctx, r.providerConfig), data.ManagerId.ValueString()).Execute()
	if err != nil {
		if httpResp != nil && httpResp.StatusCode == 404 {
			config.AddResourceNotFoundWarning(ctx, &resp.Diagnostics, "oauthAccessTokenManager", httpResp)
			resp.State.RemoveResource(ctx)
		} else {
			config.ReportHttpError(ctx, &resp.Diagnostics, "An error occurred while reading the oauthAccessTokenManager", err, httpResp)
		}
		return
	}

	// Read response into the model
	resp.Diagnostics.Append(data.readClientResponse(responseData, isImportRead)...)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *oauthAccessTokenManagerResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data oauthAccessTokenManagerResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Update API call logic
	clientData, diags := data.buildClientStruct()
	resp.Diagnostics.Append(diags...)
	apiUpdateRequest := r.apiClient.OauthAccessTokenManagersAPI.UpdateTokenManager(config.AuthContext(ctx, r.providerConfig), data.ManagerId.ValueString())
	apiUpdateRequest = apiUpdateRequest.Body(*clientData)
	responseData, httpResp, err := r.apiClient.OauthAccessTokenManagersAPI.UpdateTokenManagerExecute(apiUpdateRequest)
	if err != nil {
		config.ReportHttpError(ctx, &resp.Diagnostics, "An error occurred while updating the oauthAccessTokenManager", err, httpResp)
		return
	}

	// Read response into the model
	resp.Diagnostics.Append(data.readClientResponse(responseData, false)...)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *oauthAccessTokenManagerResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data oauthAccessTokenManagerResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Delete API call logic
	httpResp, err := r.apiClient.OauthAccessTokenManagersAPI.DeleteTokenManager(config.AuthContext(ctx, r.providerConfig), data.ManagerId.ValueString()).Execute()
	if err != nil && (httpResp == nil || httpResp.StatusCode != 404) {
		config.ReportHttpError(ctx, &resp.Diagnostics, "An error occurred while deleting the oauthAccessTokenManager", err, httpResp)
	}
}

func (r *oauthAccessTokenManagerResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Retrieve import ID and save to manager_id attribute
	resource.ImportStatePassthroughID(ctx, path.Root("manager_id"), req, resp)
	importprivatestate.MarkPrivateStateForImport(ctx, resp)
}
