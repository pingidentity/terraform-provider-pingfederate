// Copyright Â© 2025 Ping Identity Corporation

// Code generated by ping-terraform-plugin-framework-generator

package oauthclientsettings

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	client "github.com/pingidentity/pingfederate-go-client/v1230/configurationapi"
	"github.com/pingidentity/terraform-provider-pingfederate/internal/resource/config"
	"github.com/pingidentity/terraform-provider-pingfederate/internal/resource/providererror"
	internaltypes "github.com/pingidentity/terraform-provider-pingfederate/internal/types"
	"github.com/pingidentity/terraform-provider-pingfederate/internal/version"
)

var (
	_ resource.Resource                = &oauthClientSettingsResource{}
	_ resource.ResourceWithConfigure   = &oauthClientSettingsResource{}
	_ resource.ResourceWithImportState = &oauthClientSettingsResource{}
)

func OauthClientSettingsResource() resource.Resource {
	return &oauthClientSettingsResource{}
}

type oauthClientSettingsResource struct {
	providerConfig internaltypes.ProviderConfiguration
	apiClient      *client.APIClient
}

func (r *oauthClientSettingsResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_oauth_client_settings"
}

func (r *oauthClientSettingsResource) Configure(_ context.Context, req resource.ConfigureRequest, _ *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerCfg := req.ProviderData.(internaltypes.ResourceConfiguration)
	r.providerConfig = providerCfg.ProviderConfig
	r.apiClient = providerCfg.ApiClient
}

type oauthClientSettingsResourceModel struct {
	DynamicClientRegistration types.Object `tfsdk:"dynamic_client_registration"`
}

func (r *oauthClientSettingsResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Resource to manage the client settings.",
		Attributes: map[string]schema.Attribute{
			"dynamic_client_registration": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"allow_client_delete": schema.BoolAttribute{
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
						Description: "Allow client deletion from dynamic client management. Default value is `false`.",
					},
					"allowed_authorization_detail_types": schema.SetAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
						Default:     setdefault.StaticValue(emptyStringSetDefault),
						Description: "The authorization detail types to allow.",
					},
					"allowed_exclusive_scopes": schema.SetAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
						Default:     setdefault.StaticValue(emptyStringSetDefault),
						Description: "The exclusive scopes to allow.",
					},
					"bypass_activation_code_confirmation_override": schema.BoolAttribute{
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
						Description: "Indicates if the Activation Code Confirmation page should be bypassed if 'verification_url_complete' is used by the end user to authorize a device. Default value is `false`.",
					},
					"ciba_polling_interval": schema.Int64Attribute{
						Optional:    true,
						Computed:    true,
						Default:     int64default.StaticInt64(3),
						Description: "The minimum amount of time in seconds that the Client must wait between polling requests to the token endpoint. The default is `3` seconds.",
					},
					"ciba_require_signed_requests": schema.BoolAttribute{
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
						Description: "Determines whether CIBA signed requests are required for this client. Default value is `false`.",
					},
					"client_cert_issuer_ref": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Required:    true,
								Description: "The ID of the resource.",
							},
						},
						Optional:    true,
						Description: "Client TLS Certificate Issuer DN.",
					},
					"client_cert_issuer_type": schema.StringAttribute{
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("NONE"),
						Description: "Client TLS Certificate Issuer Type. Options are `NONE`, `TRUST_ANY`, `CERTIFICATE`. Defaults to `NONE`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"NONE",
								"TRUST_ANY",
								"CERTIFICATE",
							),
						},
					},
					"client_secret_retention_period_override": schema.Int64Attribute{
						Optional:    true,
						Description: "The length of time in minutes that client secrets will be retained as secondary secrets after secret change. The default value is `0`, which will disable secondary client secret retention. This value will override the `client_secret_retention_period` value on the Authorization Server Settings.",
					},
					"client_secret_retention_period_type": schema.StringAttribute{
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("SERVER_DEFAULT"),
						Description: "Use `OVERRIDE_SERVER_DEFAULT` to override the Client Secret Retention Period value on the Authorization Server Settings. `SERVER_DEFAULT` will default to the Client Secret Retention Period value on the Authorization Server Setting. Defaults to `SERVER_DEFAULT`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"SERVER_DEFAULT",
								"OVERRIDE_SERVER_DEFAULT",
							),
						},
					},
					"default_access_token_manager_ref": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Required:    true,
								Description: "The ID of the resource.",
							},
						},
						Optional:    true,
						Description: "The default access token manager for this client.",
					},
					"device_flow_setting_type": schema.StringAttribute{
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("SERVER_DEFAULT"),
						Description: "Allows an administrator to override the Device Authorization Settings set globally for the OAuth AS. Defaults to `SERVER_DEFAULT`. Options are `SERVER_DEFAULT`, `OVERRIDE_SERVER_DEFAULT`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"SERVER_DEFAULT",
								"OVERRIDE_SERVER_DEFAULT",
							),
						},
					},
					"device_polling_interval_override": schema.Int64Attribute{
						Optional:    true,
						Description: "The amount of time client should wait between polling requests, in seconds.",
					},
					"disable_registration_access_tokens": schema.BoolAttribute{
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
						Description: "Disable registration access tokens. Local standards may mandate different registration access token requirements. If applicable, implement custom validation and enforcement rules using the DynamicClientRegistrationPlugin interface from the PingFederate SDK, configure the client registration policies (`policy_refs`), and set this property (`disable_registration_access_tokens`) to `true`. CAUTION: When the `disable_registration_access_tokens` property is set to `true`, all clients, not just the ones created using the Dynamic Client Registration protocol, are vulnerable to unrestricted retrievals, updates (including modifications to the client authentication scheme and redirect URIs), and deletes at the /as/clients.oauth2 endpoint unless one or more client registration policies are in place to protect against unauthorized attempts. Default value is `false`.",
					},
					"enforce_replay_prevention": schema.BoolAttribute{
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
						Description: "Enforce replay prevention. Default value is `false`.",
					},
					"initial_access_token_scope": schema.StringAttribute{
						Optional:    true,
						Description: "The initial access token to prevent unwanted client registrations.",
					},
					"lockout_max_malicious_actions": schema.Int64Attribute{
						Optional:    true,
						Description: "The number of malicious actions allowed before an OAuth client is locked out. Currently, the only operation that is tracked as a malicious action is an attempt to revoke an invalid access token or refresh token. This value will override the global `MaxMaliciousActions` value on the `AccountLockingService` in the config-store. Supported in PingFederate `12.2` and newer.",
					},
					"lockout_max_malicious_actions_type": schema.StringAttribute{
						Optional:    true,
						Computed:    true,
						Description: "Allows an administrator to override the Max Malicious Actions configuration set globally in AccountLockingService. Defaults to `SERVER_DEFAULT`. Supported values are `DO_NOT_LOCKOUT`, `SERVER_DEFAULT`, `OVERRIDE_SERVER_DEFAULT`. Supported in PingFederate `12.2` and newer.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"DO_NOT_LOCKOUT",
								"SERVER_DEFAULT",
								"OVERRIDE_SERVER_DEFAULT",
							),
						},
					},
					"offline_access_require_consent_prompt": schema.StringAttribute{
						Optional:    true,
						Computed:    true,
						Description: "Determines whether offline_access requires the prompt parameter value to be set to 'consent' or not. The value will be reset to default if the `require_offline_access_scope_to_issue_refresh_tokens` attribute is set to `SERVER_DEFAULT` or `false`. `SERVER_DEFAULT` is the default value. Options are `SERVER_DEFAULT`, `NO`, `YES`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"SERVER_DEFAULT",
								"NO",
								"YES",
							),
						},
					},
					"oidc_policy": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"id_token_content_encryption_algorithm": schema.StringAttribute{
								Optional:    true,
								Description: "The JSON Web Encryption [JWE] content encryption algorithm for the ID Token.<br>AES_128_CBC_HMAC_SHA_256 - Composite AES-CBC-128 HMAC-SHA-256<br>AES_192_CBC_HMAC_SHA_384 - Composite AES-CBC-192 HMAC-SHA-384<br>AES_256_CBC_HMAC_SHA_512 - Composite AES-CBC-256 HMAC-SHA-512<br>AES_128_GCM - AES-GCM-128<br>AES_192_GCM - AES-GCM-192<br>AES_256_GCM - AES-GCM-256",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"AES_128_CBC_HMAC_SHA_256",
										"AES_192_CBC_HMAC_SHA_384",
										"AES_256_CBC_HMAC_SHA_512",
										"AES_128_GCM",
										"AES_192_GCM",
										"AES_256_GCM",
									),
								},
							},
							"id_token_encryption_algorithm": schema.StringAttribute{
								Optional:    true,
								Description: "The JSON Web Encryption [JWE] encryption algorithm used to encrypt the content encryption key for the ID Token.<br>DIR - Direct Encryption with symmetric key<br>A128KW - AES-128 Key Wrap<br>A192KW - AES-192 Key Wrap<br>A256KW - AES-256 Key Wrap<br>A128GCMKW - AES-GCM-128 key encryption<br>A192GCMKW - AES-GCM-192 key encryption<br>A256GCMKW - AES-GCM-256 key encryption<br>ECDH_ES - ECDH-ES<br>ECDH_ES_A128KW - ECDH-ES with AES-128 Key Wrap<br>ECDH_ES_A192KW - ECDH-ES with AES-192 Key Wrap<br>ECDH_ES_A256KW - ECDH-ES with AES-256 Key Wrap<br>RSA_OAEP - RSAES OAEP<br>RSA_OAEP_256 - RSAES OAEP using SHA-256 and MGF1 with SHA-256",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"DIR",
										"A128KW",
										"A192KW",
										"A256KW",
										"A128GCMKW",
										"A192GCMKW",
										"A256GCMKW",
										"ECDH_ES",
										"ECDH_ES_A128KW",
										"ECDH_ES_A192KW",
										"ECDH_ES_A256KW",
										"RSA_OAEP",
										"RSA_OAEP_256",
									),
								},
							},
							"id_token_signing_algorithm": schema.StringAttribute{
								Optional:    true,
								Description: "The JSON Web Signature [JWS] algorithm required for the ID Token.<br>NONE - No signing algorithm<br>HS256 - HMAC using SHA-256<br>HS384 - HMAC using SHA-384<br>HS512 - HMAC using SHA-512<br>RS256 - RSA using SHA-256<br>RS384 - RSA using SHA-384<br>RS512 - RSA using SHA-512<br>ES256 - ECDSA using P256 Curve and SHA-256<br>ES384 - ECDSA using P384 Curve and SHA-384<br>ES512 - ECDSA using P521 Curve and SHA-512<br>PS256 - RSASSA-PSS using SHA-256 and MGF1 padding with SHA-256<br>PS384 - RSASSA-PSS using SHA-384 and MGF1 padding with SHA-384<br>PS512 - RSASSA-PSS using SHA-512 and MGF1 padding with SHA-512<br>A null value will represent the default algorithm which is RS256.<br>RSASSA-PSS is only supported with Thales Luna, Entrust nShield Connect or Java 11.",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"NONE",
										"HS256",
										"HS384",
										"HS512",
										"RS256",
										"RS384",
										"RS512",
										"ES256",
										"ES384",
										"ES512",
										"PS256",
										"PS384",
										"PS512",
									),
								},
							},
							"policy_group": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"id": schema.StringAttribute{
										Required:    true,
										Description: "The ID of the resource.",
									},
								},
								Optional:    true,
								Description: "The Open ID Connect policy. A null value will represent the default policy group.",
							},
						},
						Optional:    true,
						Description: "Open ID Connect Policy settings. This is included in the message only when OIDC is enabled.",
					},
					"pending_authorization_timeout_override": schema.Int64Attribute{
						Optional:    true,
						Description: "The `device_code` and `user_code` timeout, in seconds.",
					},
					"persistent_grant_expiration_time": schema.Int64Attribute{
						Optional:    true,
						Description: "The persistent grant expiration time.",
					},
					"persistent_grant_expiration_time_unit": schema.StringAttribute{
						Optional:    true,
						Description: "The persistent grant expiration time unit. Options are `MINUTES`, `DAYS`, `HOURS`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"MINUTES",
								"DAYS",
								"HOURS",
							),
						},
					},
					"persistent_grant_expiration_type": schema.StringAttribute{
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("SERVER_DEFAULT"),
						Description: "Allows an administrator to override the Persistent Grant Lifetime set globally for the OAuth AS. Defaults to `SERVER_DEFAULT`. Options are `INDEFINITE_EXPIRY`, `SERVER_DEFAULT`, `OVERRIDE_SERVER_DEFAULT`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"INDEFINITE_EXPIRY",
								"SERVER_DEFAULT",
								"OVERRIDE_SERVER_DEFAULT",
							),
						},
					},
					"persistent_grant_idle_timeout": schema.Int64Attribute{
						Optional:    true,
						Description: "The persistent grant idle timeout.",
					},
					"persistent_grant_idle_timeout_time_unit": schema.StringAttribute{
						Optional:    true,
						Description: "The persistent grant idle timeout time unit. Options are `MINUTES`, `DAYS`, `HOURS`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"MINUTES",
								"DAYS",
								"HOURS",
							),
						},
					},
					"persistent_grant_idle_timeout_type": schema.StringAttribute{
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("SERVER_DEFAULT"),
						Description: "Allows an administrator to override the Persistent Grant Idle Timeout set globally for the OAuth AS. Defaults to `SERVER_DEFAULT`. Options are `INDEFINITE_EXPIRY`, `SERVER_DEFAULT`, `OVERRIDE_SERVER_DEFAULT`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"INDEFINITE_EXPIRY",
								"SERVER_DEFAULT",
								"OVERRIDE_SERVER_DEFAULT",
							),
						},
					},
					"policy_refs": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Required:    true,
									Description: "The ID of the resource.",
								},
							},
						},
						Optional:    true,
						Computed:    true,
						Default:     listdefault.StaticValue(emptyRefListDefault),
						Description: "The client registration policies.",
					},
					"refresh_rolling": schema.StringAttribute{
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("SERVER_DEFAULT"),
						Description: "Use `ROLL` or `DONT_ROLL` to override the `roll_refresh_token_values` setting on the Authorization Server Settings. `SERVER_DEFAULT` will default to the `roll_refresh_token_values` setting on the Authorization Server Setting screen. Defaults to `SERVER_DEFAULT`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"SERVER_DEFAULT",
								"DONT_ROLL",
								"ROLL",
							),
						},
					},
					"refresh_token_rolling_grace_period": schema.Int64Attribute{
						Optional:    true,
						Description: "The grace period that a rolled refresh token remains valid in seconds.",
					},
					"refresh_token_rolling_grace_period_type": schema.StringAttribute{
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("SERVER_DEFAULT"),
						Description: "When set to `OVERRIDE_SERVER_DEFAULT`, it overrides the global `refresh_token_grace_period` defined in the Authorization Server Settings. The default value is `SERVER_DEFAULT`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"SERVER_DEFAULT",
								"OVERRIDE_SERVER_DEFAULT",
							),
						},
					},
					"refresh_token_rolling_interval": schema.Int64Attribute{
						Optional:    true,
						Description: "The minimum interval to roll refresh tokens. This value will override the `refresh_token_rolling_interval` value on the Authorization Server Settings.",
					},
					"refresh_token_rolling_interval_time_unit": schema.StringAttribute{
						Optional:    true,
						Description: "The refresh token rolling interval time unit. Defaults to `HOURS`. Options are `SECONDS`, `MINUTES`, `HOURS`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"SECONDS",
								"MINUTES",
								"HOURS",
							),
						},
					},
					"refresh_token_rolling_interval_type": schema.StringAttribute{
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("SERVER_DEFAULT"),
						Description: "Use `OVERRIDE_SERVER_DEFAULT` to override the `refresh_token_rolling_interval` value on the Authorization Server Settings. `SERVER_DEFAULT` will default to the `refresh_token_rolling_interval` value on the Authorization Server Setting. Defaults to SERVER_DEFAULT.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"SERVER_DEFAULT",
								"OVERRIDE_SERVER_DEFAULT",
							),
						},
					},
					"request_policy_ref": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Required:    true,
								Description: "The ID of the resource.",
							},
						},
						Optional:    true,
						Description: "The CIBA request policy.",
					},
					"require_jwt_secured_authorization_response_mode": schema.BoolAttribute{
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
						Description: "Determines whether JWT Secured authorization response mode is required when initiating an authorization request. The default is `false`.",
					},
					"require_offline_access_scope_to_issue_refresh_tokens": schema.StringAttribute{
						Optional:    true,
						Computed:    true,
						Description: "Determines whether offline_access scope is required to issue refresh tokens or not. 'SERVER_DEFAULT' is the default value. Options are `SERVER_DEFAULT`, `NO`, `YES`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"SERVER_DEFAULT",
								"NO",
								"YES",
							),
						},
					},
					"require_proof_key_for_code_exchange": schema.BoolAttribute{
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
						Description: "Determines whether Proof Key for Code Exchange (PKCE) is required for the dynamically created client. Default value is `false`.",
					},
					"require_signed_requests": schema.BoolAttribute{
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
						Description: "Require signed requests. Default value is `false`.",
					},
					"restrict_common_scopes": schema.BoolAttribute{
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
						Description: "Restrict common scopes. Default value is `false`.",
					},
					"restrict_to_default_access_token_manager": schema.BoolAttribute{
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
						Description: "Determines whether the client is restricted to using only its default access token manager. The default is `false`.",
					},
					"restricted_common_scopes": schema.SetAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
						Default:     setdefault.StaticValue(emptyStringSetDefault),
						Description: "The common scopes to restrict.",
					},
					"retain_client_secret": schema.BoolAttribute{
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
						Description: "Temporarily retain the old client secret on client secret change. Default value is `false`.",
					},
					"rotate_client_secret": schema.BoolAttribute{
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
						Description: "Rotate registration access token on dynamic client management requests. Default value is `false`.",
					},
					"rotate_registration_access_token": schema.BoolAttribute{
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
						Description: "Rotate client secret on dynamic client management requests. Default value is `false`.",
					},
					"token_exchange_processor_policy_ref": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Required:    true,
								Description: "The ID of the resource.",
							},
						},
						Optional:    true,
						Description: "The Token Exchange Processor policy.",
					},
					"user_authorization_url_override": schema.StringAttribute{
						Optional:    true,
						Description: "The URL is used as `verification_url` and `verification_url_complete` values in a Device Authorization request.",
					},
				},
				Optional:    true,
				Description: "Dynamic client registration settings.",
			},
		},
	}
}

func (r *oauthClientSettingsResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	// Compare to version 12.1.0 of PF
	compare, err := version.Compare(r.providerConfig.ProductVersion, version.PingFederate1210)
	if err != nil {
		resp.Diagnostics.AddError(providererror.InternalProviderError, "Failed to compare PingFederate versions: "+err.Error())
		return
	}
	pfVersionAtLeast1210 := compare >= 0
	// Compare to version 12.2.0 of PF
	compare, err = version.Compare(r.providerConfig.ProductVersion, version.PingFederate1220)
	if err != nil {
		resp.Diagnostics.AddError("Failed to compare PingFederate versions", err.Error())
		return
	}
	pfVersionAtLeast1220 := compare >= 0
	var plan *oauthClientSettingsResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if plan == nil {
		return
	}
	// If any of these fields are set by the user and the PF version is not new enough, throw an error
	if !pfVersionAtLeast1210 {
		if internaltypes.IsDefined(plan.DynamicClientRegistration) {
			offlineAccessRequireConsentPrompt := plan.DynamicClientRegistration.Attributes()["offline_access_require_consent_prompt"]
			if internaltypes.IsDefined(offlineAccessRequireConsentPrompt) {
				version.AddUnsupportedAttributeError("dynamic_client_registration.offline_access_require_consent_prompt",
					r.providerConfig.ProductVersion, version.PingFederate1210, &resp.Diagnostics)
			}
			refreshTokenRollingIntervalTimeUnit := plan.DynamicClientRegistration.Attributes()["refresh_token_rolling_interval_time_unit"]
			if internaltypes.IsDefined(refreshTokenRollingIntervalTimeUnit) {
				version.AddUnsupportedAttributeError("dynamic_client_registration.refresh_token_rolling_interval_time_unit",
					r.providerConfig.ProductVersion, version.PingFederate1210, &resp.Diagnostics)
			}
			requireOfflineAccessScopeToIssueRefreshTokens := plan.DynamicClientRegistration.Attributes()["require_offline_access_scope_to_issue_refresh_tokens"]
			if internaltypes.IsDefined(requireOfflineAccessScopeToIssueRefreshTokens) {
				version.AddUnsupportedAttributeError("dynamic_client_registration.require_offline_access_scope_to_issue_refresh_tokens",
					r.providerConfig.ProductVersion, version.PingFederate1210, &resp.Diagnostics)
			}
		}
	} else {
		r.validatePf121Config(ctx, req, resp)
	}
	if !pfVersionAtLeast1220 {
		if internaltypes.IsDefined(plan.DynamicClientRegistration) {
			lockoutMaxMaliciousActions := plan.DynamicClientRegistration.Attributes()["lockout_max_malicious_actions"]
			if internaltypes.IsDefined(lockoutMaxMaliciousActions) {
				version.AddUnsupportedAttributeError("dynamic_client_registration.lockout_max_malicious_actions",
					r.providerConfig.ProductVersion, version.PingFederate1220, &resp.Diagnostics)
			}
			lockoutMaxMaliciousActionsType := plan.DynamicClientRegistration.Attributes()["lockout_max_malicious_actions_type"]
			if internaltypes.IsDefined(lockoutMaxMaliciousActionsType) {
				version.AddUnsupportedAttributeError("dynamic_client_registration.lockout_max_malicious_actions_type",
					r.providerConfig.ProductVersion, version.PingFederate1220, &resp.Diagnostics)
			} else if lockoutMaxMaliciousActionsType.IsUnknown() {
				dynamicClientRegistrationAttrs := plan.DynamicClientRegistration.Attributes()
				dynamicClientRegistrationAttrs["lockout_max_malicious_actions_type"] = types.StringNull()
				var diags diag.Diagnostics
				plan.DynamicClientRegistration, diags = types.ObjectValue(plan.DynamicClientRegistration.AttributeTypes(ctx), dynamicClientRegistrationAttrs)
				resp.Diagnostics.Append(diags...)
				resp.Diagnostics.Append(resp.Plan.Set(ctx, plan)...)
			}
		}
	} else {
		if internaltypes.IsDefined(plan.DynamicClientRegistration) {
			dynamicClientRegistrationAttrs := plan.DynamicClientRegistration.Attributes()
			lockoutMaxMaliciousActionsType := dynamicClientRegistrationAttrs["lockout_max_malicious_actions_type"]
			if lockoutMaxMaliciousActionsType.IsUnknown() {
				dynamicClientRegistrationAttrs["lockout_max_malicious_actions_type"] = types.StringValue("SERVER_DEFAULT")
				var diags diag.Diagnostics
				plan.DynamicClientRegistration, diags = types.ObjectValue(plan.DynamicClientRegistration.AttributeTypes(ctx), dynamicClientRegistrationAttrs)
				resp.Diagnostics.Append(diags...)
				resp.Diagnostics.Append(resp.Plan.Set(ctx, plan)...)
			}
		}
	}
	r.setVersionDependentDefaults(ctx, plan, pfVersionAtLeast1210, resp)
}

func (model *oauthClientSettingsResourceModel) buildClientStruct(existingExtendedProperties []client.ExtendedProperty) (*client.ClientSettings, diag.Diagnostics) {
	result := &client.ClientSettings{}
	// dynamic_client_registration
	if !model.DynamicClientRegistration.IsNull() {
		dynamicClientRegistrationValue := &client.DynamicClientRegistration{}
		dynamicClientRegistrationAttrs := model.DynamicClientRegistration.Attributes()
		dynamicClientRegistrationValue.AllowClientDelete = dynamicClientRegistrationAttrs["allow_client_delete"].(types.Bool).ValueBoolPointer()
		if !dynamicClientRegistrationAttrs["allowed_authorization_detail_types"].IsNull() {
			dynamicClientRegistrationValue.AllowedAuthorizationDetailTypes = []string{}
			for _, allowedAuthorizationDetailTypesElement := range dynamicClientRegistrationAttrs["allowed_authorization_detail_types"].(types.Set).Elements() {
				dynamicClientRegistrationValue.AllowedAuthorizationDetailTypes = append(dynamicClientRegistrationValue.AllowedAuthorizationDetailTypes, allowedAuthorizationDetailTypesElement.(types.String).ValueString())
			}
		}
		if !dynamicClientRegistrationAttrs["allowed_exclusive_scopes"].IsNull() {
			dynamicClientRegistrationValue.AllowedExclusiveScopes = []string{}
			for _, allowedExclusiveScopesElement := range dynamicClientRegistrationAttrs["allowed_exclusive_scopes"].(types.Set).Elements() {
				dynamicClientRegistrationValue.AllowedExclusiveScopes = append(dynamicClientRegistrationValue.AllowedExclusiveScopes, allowedExclusiveScopesElement.(types.String).ValueString())
			}
		}
		dynamicClientRegistrationValue.BypassActivationCodeConfirmationOverride = dynamicClientRegistrationAttrs["bypass_activation_code_confirmation_override"].(types.Bool).ValueBoolPointer()
		dynamicClientRegistrationValue.CibaPollingInterval = dynamicClientRegistrationAttrs["ciba_polling_interval"].(types.Int64).ValueInt64Pointer()
		dynamicClientRegistrationValue.CibaRequireSignedRequests = dynamicClientRegistrationAttrs["ciba_require_signed_requests"].(types.Bool).ValueBoolPointer()
		if !dynamicClientRegistrationAttrs["client_cert_issuer_ref"].IsNull() {
			dynamicClientRegistrationClientCertIssuerRefValue := &client.ResourceLink{}
			dynamicClientRegistrationClientCertIssuerRefAttrs := dynamicClientRegistrationAttrs["client_cert_issuer_ref"].(types.Object).Attributes()
			dynamicClientRegistrationClientCertIssuerRefValue.Id = dynamicClientRegistrationClientCertIssuerRefAttrs["id"].(types.String).ValueString()
			dynamicClientRegistrationValue.ClientCertIssuerRef = dynamicClientRegistrationClientCertIssuerRefValue
		}
		dynamicClientRegistrationValue.ClientCertIssuerType = dynamicClientRegistrationAttrs["client_cert_issuer_type"].(types.String).ValueStringPointer()
		dynamicClientRegistrationValue.ClientSecretRetentionPeriodOverride = dynamicClientRegistrationAttrs["client_secret_retention_period_override"].(types.Int64).ValueInt64Pointer()
		dynamicClientRegistrationValue.ClientSecretRetentionPeriodType = dynamicClientRegistrationAttrs["client_secret_retention_period_type"].(types.String).ValueStringPointer()
		if !dynamicClientRegistrationAttrs["default_access_token_manager_ref"].IsNull() {
			dynamicClientRegistrationDefaultAccessTokenManagerRefValue := &client.ResourceLink{}
			dynamicClientRegistrationDefaultAccessTokenManagerRefAttrs := dynamicClientRegistrationAttrs["default_access_token_manager_ref"].(types.Object).Attributes()
			dynamicClientRegistrationDefaultAccessTokenManagerRefValue.Id = dynamicClientRegistrationDefaultAccessTokenManagerRefAttrs["id"].(types.String).ValueString()
			dynamicClientRegistrationValue.DefaultAccessTokenManagerRef = dynamicClientRegistrationDefaultAccessTokenManagerRefValue
		}
		dynamicClientRegistrationValue.DeviceFlowSettingType = dynamicClientRegistrationAttrs["device_flow_setting_type"].(types.String).ValueStringPointer()
		dynamicClientRegistrationValue.DevicePollingIntervalOverride = dynamicClientRegistrationAttrs["device_polling_interval_override"].(types.Int64).ValueInt64Pointer()
		dynamicClientRegistrationValue.DisableRegistrationAccessTokens = dynamicClientRegistrationAttrs["disable_registration_access_tokens"].(types.Bool).ValueBoolPointer()
		dynamicClientRegistrationValue.EnforceReplayPrevention = dynamicClientRegistrationAttrs["enforce_replay_prevention"].(types.Bool).ValueBoolPointer()
		dynamicClientRegistrationValue.InitialAccessTokenScope = dynamicClientRegistrationAttrs["initial_access_token_scope"].(types.String).ValueStringPointer()
		dynamicClientRegistrationValue.LockoutMaxMaliciousActions = dynamicClientRegistrationAttrs["lockout_max_malicious_actions"].(types.Int64).ValueInt64Pointer()
		dynamicClientRegistrationValue.LockoutMaxMaliciousActionsType = dynamicClientRegistrationAttrs["lockout_max_malicious_actions_type"].(types.String).ValueStringPointer()
		dynamicClientRegistrationValue.OfflineAccessRequireConsentPrompt = dynamicClientRegistrationAttrs["offline_access_require_consent_prompt"].(types.String).ValueStringPointer()
		if !dynamicClientRegistrationAttrs["oidc_policy"].IsNull() {
			dynamicClientRegistrationOidcPolicyValue := &client.ClientRegistrationOIDCPolicy{}
			dynamicClientRegistrationOidcPolicyAttrs := dynamicClientRegistrationAttrs["oidc_policy"].(types.Object).Attributes()
			dynamicClientRegistrationOidcPolicyValue.IdTokenContentEncryptionAlgorithm = dynamicClientRegistrationOidcPolicyAttrs["id_token_content_encryption_algorithm"].(types.String).ValueStringPointer()
			dynamicClientRegistrationOidcPolicyValue.IdTokenEncryptionAlgorithm = dynamicClientRegistrationOidcPolicyAttrs["id_token_encryption_algorithm"].(types.String).ValueStringPointer()
			dynamicClientRegistrationOidcPolicyValue.IdTokenSigningAlgorithm = dynamicClientRegistrationOidcPolicyAttrs["id_token_signing_algorithm"].(types.String).ValueStringPointer()
			if !dynamicClientRegistrationOidcPolicyAttrs["policy_group"].IsNull() {
				dynamicClientRegistrationOidcPolicyPolicyGroupValue := &client.ResourceLink{}
				dynamicClientRegistrationOidcPolicyPolicyGroupAttrs := dynamicClientRegistrationOidcPolicyAttrs["policy_group"].(types.Object).Attributes()
				dynamicClientRegistrationOidcPolicyPolicyGroupValue.Id = dynamicClientRegistrationOidcPolicyPolicyGroupAttrs["id"].(types.String).ValueString()
				dynamicClientRegistrationOidcPolicyValue.PolicyGroup = dynamicClientRegistrationOidcPolicyPolicyGroupValue
			}
			dynamicClientRegistrationValue.OidcPolicy = dynamicClientRegistrationOidcPolicyValue
		}
		dynamicClientRegistrationValue.PendingAuthorizationTimeoutOverride = dynamicClientRegistrationAttrs["pending_authorization_timeout_override"].(types.Int64).ValueInt64Pointer()
		dynamicClientRegistrationValue.PersistentGrantExpirationTime = dynamicClientRegistrationAttrs["persistent_grant_expiration_time"].(types.Int64).ValueInt64Pointer()
		dynamicClientRegistrationValue.PersistentGrantExpirationTimeUnit = dynamicClientRegistrationAttrs["persistent_grant_expiration_time_unit"].(types.String).ValueStringPointer()
		dynamicClientRegistrationValue.PersistentGrantExpirationType = dynamicClientRegistrationAttrs["persistent_grant_expiration_type"].(types.String).ValueStringPointer()
		dynamicClientRegistrationValue.PersistentGrantIdleTimeout = dynamicClientRegistrationAttrs["persistent_grant_idle_timeout"].(types.Int64).ValueInt64Pointer()
		dynamicClientRegistrationValue.PersistentGrantIdleTimeoutTimeUnit = dynamicClientRegistrationAttrs["persistent_grant_idle_timeout_time_unit"].(types.String).ValueStringPointer()
		dynamicClientRegistrationValue.PersistentGrantIdleTimeoutType = dynamicClientRegistrationAttrs["persistent_grant_idle_timeout_type"].(types.String).ValueStringPointer()
		dynamicClientRegistrationValue.PolicyRefs = []client.ResourceLink{}
		for _, policyRefsElement := range dynamicClientRegistrationAttrs["policy_refs"].(types.List).Elements() {
			policyRefsValue := client.ResourceLink{}
			policyRefsAttrs := policyRefsElement.(types.Object).Attributes()
			policyRefsValue.Id = policyRefsAttrs["id"].(types.String).ValueString()
			dynamicClientRegistrationValue.PolicyRefs = append(dynamicClientRegistrationValue.PolicyRefs, policyRefsValue)
		}
		dynamicClientRegistrationValue.RefreshRolling = dynamicClientRegistrationAttrs["refresh_rolling"].(types.String).ValueStringPointer()
		dynamicClientRegistrationValue.RefreshTokenRollingGracePeriod = dynamicClientRegistrationAttrs["refresh_token_rolling_grace_period"].(types.Int64).ValueInt64Pointer()
		dynamicClientRegistrationValue.RefreshTokenRollingGracePeriodType = dynamicClientRegistrationAttrs["refresh_token_rolling_grace_period_type"].(types.String).ValueStringPointer()
		dynamicClientRegistrationValue.RefreshTokenRollingInterval = dynamicClientRegistrationAttrs["refresh_token_rolling_interval"].(types.Int64).ValueInt64Pointer()
		dynamicClientRegistrationValue.RefreshTokenRollingIntervalTimeUnit = dynamicClientRegistrationAttrs["refresh_token_rolling_interval_time_unit"].(types.String).ValueStringPointer()
		dynamicClientRegistrationValue.RefreshTokenRollingIntervalType = dynamicClientRegistrationAttrs["refresh_token_rolling_interval_type"].(types.String).ValueStringPointer()
		if !dynamicClientRegistrationAttrs["request_policy_ref"].IsNull() {
			dynamicClientRegistrationRequestPolicyRefValue := &client.ResourceLink{}
			dynamicClientRegistrationRequestPolicyRefAttrs := dynamicClientRegistrationAttrs["request_policy_ref"].(types.Object).Attributes()
			dynamicClientRegistrationRequestPolicyRefValue.Id = dynamicClientRegistrationRequestPolicyRefAttrs["id"].(types.String).ValueString()
			dynamicClientRegistrationValue.RequestPolicyRef = dynamicClientRegistrationRequestPolicyRefValue
		}
		dynamicClientRegistrationValue.RequireJwtSecuredAuthorizationResponseMode = dynamicClientRegistrationAttrs["require_jwt_secured_authorization_response_mode"].(types.Bool).ValueBoolPointer()
		dynamicClientRegistrationValue.RequireOfflineAccessScopeToIssueRefreshTokens = dynamicClientRegistrationAttrs["require_offline_access_scope_to_issue_refresh_tokens"].(types.String).ValueStringPointer()
		dynamicClientRegistrationValue.RequireProofKeyForCodeExchange = dynamicClientRegistrationAttrs["require_proof_key_for_code_exchange"].(types.Bool).ValueBoolPointer()
		dynamicClientRegistrationValue.RequireSignedRequests = dynamicClientRegistrationAttrs["require_signed_requests"].(types.Bool).ValueBoolPointer()
		dynamicClientRegistrationValue.RestrictCommonScopes = dynamicClientRegistrationAttrs["restrict_common_scopes"].(types.Bool).ValueBoolPointer()
		dynamicClientRegistrationValue.RestrictToDefaultAccessTokenManager = dynamicClientRegistrationAttrs["restrict_to_default_access_token_manager"].(types.Bool).ValueBoolPointer()
		if !dynamicClientRegistrationAttrs["restricted_common_scopes"].IsNull() {
			dynamicClientRegistrationValue.RestrictedCommonScopes = []string{}
			for _, restrictedCommonScopesElement := range dynamicClientRegistrationAttrs["restricted_common_scopes"].(types.Set).Elements() {
				dynamicClientRegistrationValue.RestrictedCommonScopes = append(dynamicClientRegistrationValue.RestrictedCommonScopes, restrictedCommonScopesElement.(types.String).ValueString())
			}
		}
		dynamicClientRegistrationValue.RetainClientSecret = dynamicClientRegistrationAttrs["retain_client_secret"].(types.Bool).ValueBoolPointer()
		dynamicClientRegistrationValue.RotateClientSecret = dynamicClientRegistrationAttrs["rotate_client_secret"].(types.Bool).ValueBoolPointer()
		dynamicClientRegistrationValue.RotateRegistrationAccessToken = dynamicClientRegistrationAttrs["rotate_registration_access_token"].(types.Bool).ValueBoolPointer()
		if !dynamicClientRegistrationAttrs["token_exchange_processor_policy_ref"].IsNull() {
			dynamicClientRegistrationTokenExchangeProcessorPolicyRefValue := &client.ResourceLink{}
			dynamicClientRegistrationTokenExchangeProcessorPolicyRefAttrs := dynamicClientRegistrationAttrs["token_exchange_processor_policy_ref"].(types.Object).Attributes()
			dynamicClientRegistrationTokenExchangeProcessorPolicyRefValue.Id = dynamicClientRegistrationTokenExchangeProcessorPolicyRefAttrs["id"].(types.String).ValueString()
			dynamicClientRegistrationValue.TokenExchangeProcessorPolicyRef = dynamicClientRegistrationTokenExchangeProcessorPolicyRefValue
		}
		dynamicClientRegistrationValue.UserAuthorizationUrlOverride = dynamicClientRegistrationAttrs["user_authorization_url_override"].(types.String).ValueStringPointer()
		result.DynamicClientRegistration = dynamicClientRegistrationValue
	}

	result.ClientMetadata = []client.ClientMetadata{}
	for _, extendedProperty := range existingExtendedProperties {
		result.ClientMetadata = append(result.ClientMetadata, client.ClientMetadata{
			Parameter:   extendedProperty.Name,
			Description: extendedProperty.Description,
			MultiValued: extendedProperty.MultiValued,
		})
	}

	return result, nil
}

func (state *oauthClientSettingsResourceModel) readClientResponse(response *client.ClientSettings) diag.Diagnostics {
	var respDiags diag.Diagnostics
	// dynamic_client_registration
	dynamicClientRegistrationClientCertIssuerRefAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	dynamicClientRegistrationDefaultAccessTokenManagerRefAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	dynamicClientRegistrationOidcPolicyPolicyGroupAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	dynamicClientRegistrationOidcPolicyAttrTypes := map[string]attr.Type{
		"id_token_content_encryption_algorithm": types.StringType,
		"id_token_encryption_algorithm":         types.StringType,
		"id_token_signing_algorithm":            types.StringType,
		"policy_group":                          types.ObjectType{AttrTypes: dynamicClientRegistrationOidcPolicyPolicyGroupAttrTypes},
	}
	dynamicClientRegistrationPolicyRefsAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	dynamicClientRegistrationPolicyRefsElementType := types.ObjectType{AttrTypes: dynamicClientRegistrationPolicyRefsAttrTypes}
	dynamicClientRegistrationRequestPolicyRefAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	dynamicClientRegistrationTokenExchangeProcessorPolicyRefAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	dynamicClientRegistrationAttrTypes := map[string]attr.Type{
		"allow_client_delete":                                  types.BoolType,
		"allowed_authorization_detail_types":                   types.SetType{ElemType: types.StringType},
		"allowed_exclusive_scopes":                             types.SetType{ElemType: types.StringType},
		"bypass_activation_code_confirmation_override":         types.BoolType,
		"ciba_polling_interval":                                types.Int64Type,
		"ciba_require_signed_requests":                         types.BoolType,
		"client_cert_issuer_ref":                               types.ObjectType{AttrTypes: dynamicClientRegistrationClientCertIssuerRefAttrTypes},
		"client_cert_issuer_type":                              types.StringType,
		"client_secret_retention_period_override":              types.Int64Type,
		"client_secret_retention_period_type":                  types.StringType,
		"default_access_token_manager_ref":                     types.ObjectType{AttrTypes: dynamicClientRegistrationDefaultAccessTokenManagerRefAttrTypes},
		"device_flow_setting_type":                             types.StringType,
		"device_polling_interval_override":                     types.Int64Type,
		"disable_registration_access_tokens":                   types.BoolType,
		"enforce_replay_prevention":                            types.BoolType,
		"initial_access_token_scope":                           types.StringType,
		"offline_access_require_consent_prompt":                types.StringType,
		"lockout_max_malicious_actions":                        types.Int64Type,
		"lockout_max_malicious_actions_type":                   types.StringType,
		"oidc_policy":                                          types.ObjectType{AttrTypes: dynamicClientRegistrationOidcPolicyAttrTypes},
		"pending_authorization_timeout_override":               types.Int64Type,
		"persistent_grant_expiration_time":                     types.Int64Type,
		"persistent_grant_expiration_time_unit":                types.StringType,
		"persistent_grant_expiration_type":                     types.StringType,
		"persistent_grant_idle_timeout":                        types.Int64Type,
		"persistent_grant_idle_timeout_time_unit":              types.StringType,
		"persistent_grant_idle_timeout_type":                   types.StringType,
		"policy_refs":                                          types.ListType{ElemType: dynamicClientRegistrationPolicyRefsElementType},
		"refresh_rolling":                                      types.StringType,
		"refresh_token_rolling_grace_period":                   types.Int64Type,
		"refresh_token_rolling_grace_period_type":              types.StringType,
		"refresh_token_rolling_interval":                       types.Int64Type,
		"refresh_token_rolling_interval_time_unit":             types.StringType,
		"refresh_token_rolling_interval_type":                  types.StringType,
		"request_policy_ref":                                   types.ObjectType{AttrTypes: dynamicClientRegistrationRequestPolicyRefAttrTypes},
		"require_jwt_secured_authorization_response_mode":      types.BoolType,
		"require_offline_access_scope_to_issue_refresh_tokens": types.StringType,
		"require_proof_key_for_code_exchange":                  types.BoolType,
		"require_signed_requests":                              types.BoolType,
		"restrict_common_scopes":                               types.BoolType,
		"restrict_to_default_access_token_manager":             types.BoolType,
		"restricted_common_scopes":                             types.SetType{ElemType: types.StringType},
		"retain_client_secret":                                 types.BoolType,
		"rotate_client_secret":                                 types.BoolType,
		"rotate_registration_access_token":                     types.BoolType,
		"token_exchange_processor_policy_ref":                  types.ObjectType{AttrTypes: dynamicClientRegistrationTokenExchangeProcessorPolicyRefAttrTypes},
		"user_authorization_url_override":                      types.StringType,
	}
	var dynamicClientRegistrationValue types.Object
	if response.DynamicClientRegistration == nil {
		dynamicClientRegistrationValue = types.ObjectNull(dynamicClientRegistrationAttrTypes)
	} else {
		dynamicClientRegistrationAllowedAuthorizationDetailTypesValue, diags := types.SetValueFrom(context.Background(), types.StringType, response.DynamicClientRegistration.AllowedAuthorizationDetailTypes)
		respDiags.Append(diags...)
		dynamicClientRegistrationAllowedExclusiveScopesValue, diags := types.SetValueFrom(context.Background(), types.StringType, response.DynamicClientRegistration.AllowedExclusiveScopes)
		respDiags.Append(diags...)
		var dynamicClientRegistrationClientCertIssuerRefValue types.Object
		if response.DynamicClientRegistration.ClientCertIssuerRef == nil {
			dynamicClientRegistrationClientCertIssuerRefValue = types.ObjectNull(dynamicClientRegistrationClientCertIssuerRefAttrTypes)
		} else {
			dynamicClientRegistrationClientCertIssuerRefValue, diags = types.ObjectValue(dynamicClientRegistrationClientCertIssuerRefAttrTypes, map[string]attr.Value{
				"id": types.StringValue(response.DynamicClientRegistration.ClientCertIssuerRef.Id),
			})
			respDiags.Append(diags...)
		}
		var dynamicClientRegistrationDefaultAccessTokenManagerRefValue types.Object
		if response.DynamicClientRegistration.DefaultAccessTokenManagerRef == nil {
			dynamicClientRegistrationDefaultAccessTokenManagerRefValue = types.ObjectNull(dynamicClientRegistrationDefaultAccessTokenManagerRefAttrTypes)
		} else {
			dynamicClientRegistrationDefaultAccessTokenManagerRefValue, diags = types.ObjectValue(dynamicClientRegistrationDefaultAccessTokenManagerRefAttrTypes, map[string]attr.Value{
				"id": types.StringValue(response.DynamicClientRegistration.DefaultAccessTokenManagerRef.Id),
			})
			respDiags.Append(diags...)
		}
		var dynamicClientRegistrationOidcPolicyValue types.Object
		if response.DynamicClientRegistration.OidcPolicy == nil {
			dynamicClientRegistrationOidcPolicyValue = types.ObjectNull(dynamicClientRegistrationOidcPolicyAttrTypes)
		} else {
			var dynamicClientRegistrationOidcPolicyPolicyGroupValue types.Object
			if response.DynamicClientRegistration.OidcPolicy.PolicyGroup == nil {
				dynamicClientRegistrationOidcPolicyPolicyGroupValue = types.ObjectNull(dynamicClientRegistrationOidcPolicyPolicyGroupAttrTypes)
			} else {
				dynamicClientRegistrationOidcPolicyPolicyGroupValue, diags = types.ObjectValue(dynamicClientRegistrationOidcPolicyPolicyGroupAttrTypes, map[string]attr.Value{
					"id": types.StringValue(response.DynamicClientRegistration.OidcPolicy.PolicyGroup.Id),
				})
				respDiags.Append(diags...)
			}
			dynamicClientRegistrationOidcPolicyValue, diags = types.ObjectValue(dynamicClientRegistrationOidcPolicyAttrTypes, map[string]attr.Value{
				"id_token_content_encryption_algorithm": types.StringPointerValue(response.DynamicClientRegistration.OidcPolicy.IdTokenContentEncryptionAlgorithm),
				"id_token_encryption_algorithm":         types.StringPointerValue(response.DynamicClientRegistration.OidcPolicy.IdTokenEncryptionAlgorithm),
				"id_token_signing_algorithm":            types.StringPointerValue(response.DynamicClientRegistration.OidcPolicy.IdTokenSigningAlgorithm),
				"policy_group":                          dynamicClientRegistrationOidcPolicyPolicyGroupValue,
			})
			respDiags.Append(diags...)
		}
		var dynamicClientRegistrationPolicyRefsValues []attr.Value
		for _, dynamicClientRegistrationPolicyRefsResponseValue := range response.DynamicClientRegistration.PolicyRefs {
			dynamicClientRegistrationPolicyRefsValue, diags := types.ObjectValue(dynamicClientRegistrationPolicyRefsAttrTypes, map[string]attr.Value{
				"id": types.StringValue(dynamicClientRegistrationPolicyRefsResponseValue.Id),
			})
			respDiags.Append(diags...)
			dynamicClientRegistrationPolicyRefsValues = append(dynamicClientRegistrationPolicyRefsValues, dynamicClientRegistrationPolicyRefsValue)
		}
		dynamicClientRegistrationPolicyRefsValue, diags := types.ListValue(dynamicClientRegistrationPolicyRefsElementType, dynamicClientRegistrationPolicyRefsValues)
		respDiags.Append(diags...)
		var dynamicClientRegistrationRequestPolicyRefValue types.Object
		if response.DynamicClientRegistration.RequestPolicyRef == nil {
			dynamicClientRegistrationRequestPolicyRefValue = types.ObjectNull(dynamicClientRegistrationRequestPolicyRefAttrTypes)
		} else {
			dynamicClientRegistrationRequestPolicyRefValue, diags = types.ObjectValue(dynamicClientRegistrationRequestPolicyRefAttrTypes, map[string]attr.Value{
				"id": types.StringValue(response.DynamicClientRegistration.RequestPolicyRef.Id),
			})
			respDiags.Append(diags...)
		}
		dynamicClientRegistrationRestrictedCommonScopesValue, diags := types.SetValueFrom(context.Background(), types.StringType, response.DynamicClientRegistration.RestrictedCommonScopes)
		respDiags.Append(diags...)
		var dynamicClientRegistrationTokenExchangeProcessorPolicyRefValue types.Object
		if response.DynamicClientRegistration.TokenExchangeProcessorPolicyRef == nil {
			dynamicClientRegistrationTokenExchangeProcessorPolicyRefValue = types.ObjectNull(dynamicClientRegistrationTokenExchangeProcessorPolicyRefAttrTypes)
		} else {
			dynamicClientRegistrationTokenExchangeProcessorPolicyRefValue, diags = types.ObjectValue(dynamicClientRegistrationTokenExchangeProcessorPolicyRefAttrTypes, map[string]attr.Value{
				"id": types.StringValue(response.DynamicClientRegistration.TokenExchangeProcessorPolicyRef.Id),
			})
			respDiags.Append(diags...)
		}
		// Sometimes PF won't return DisableRegistrationAccessTokens at all when it is set to false
		disableRegistrationAccessTokens := false
		if response.DynamicClientRegistration.DisableRegistrationAccessTokens != nil {
			disableRegistrationAccessTokens = *response.DynamicClientRegistration.DisableRegistrationAccessTokens
		}
		// Sometimes PF won't return grace_period_type when it's set to SERVER_DEFAULT
		gracePeriodType := "SERVER_DEFAULT"
		if response.DynamicClientRegistration.RefreshTokenRollingGracePeriodType != nil {
			gracePeriodType = *response.DynamicClientRegistration.RefreshTokenRollingGracePeriodType
		}
		dynamicClientRegistrationValue, diags = types.ObjectValue(dynamicClientRegistrationAttrTypes, map[string]attr.Value{
			"allow_client_delete":                                  types.BoolPointerValue(response.DynamicClientRegistration.AllowClientDelete),
			"allowed_authorization_detail_types":                   dynamicClientRegistrationAllowedAuthorizationDetailTypesValue,
			"allowed_exclusive_scopes":                             dynamicClientRegistrationAllowedExclusiveScopesValue,
			"bypass_activation_code_confirmation_override":         types.BoolPointerValue(response.DynamicClientRegistration.BypassActivationCodeConfirmationOverride),
			"ciba_polling_interval":                                types.Int64PointerValue(response.DynamicClientRegistration.CibaPollingInterval),
			"ciba_require_signed_requests":                         types.BoolPointerValue(response.DynamicClientRegistration.CibaRequireSignedRequests),
			"client_cert_issuer_ref":                               dynamicClientRegistrationClientCertIssuerRefValue,
			"client_cert_issuer_type":                              types.StringPointerValue(response.DynamicClientRegistration.ClientCertIssuerType),
			"client_secret_retention_period_override":              types.Int64PointerValue(response.DynamicClientRegistration.ClientSecretRetentionPeriodOverride),
			"client_secret_retention_period_type":                  types.StringPointerValue(response.DynamicClientRegistration.ClientSecretRetentionPeriodType),
			"default_access_token_manager_ref":                     dynamicClientRegistrationDefaultAccessTokenManagerRefValue,
			"device_flow_setting_type":                             types.StringPointerValue(response.DynamicClientRegistration.DeviceFlowSettingType),
			"device_polling_interval_override":                     types.Int64PointerValue(response.DynamicClientRegistration.DevicePollingIntervalOverride),
			"disable_registration_access_tokens":                   types.BoolValue(disableRegistrationAccessTokens),
			"enforce_replay_prevention":                            types.BoolPointerValue(response.DynamicClientRegistration.EnforceReplayPrevention),
			"initial_access_token_scope":                           types.StringPointerValue(response.DynamicClientRegistration.InitialAccessTokenScope),
			"lockout_max_malicious_actions":                        types.Int64PointerValue(response.DynamicClientRegistration.LockoutMaxMaliciousActions),
			"lockout_max_malicious_actions_type":                   types.StringPointerValue(response.DynamicClientRegistration.LockoutMaxMaliciousActionsType),
			"offline_access_require_consent_prompt":                types.StringPointerValue(response.DynamicClientRegistration.OfflineAccessRequireConsentPrompt),
			"oidc_policy":                                          dynamicClientRegistrationOidcPolicyValue,
			"pending_authorization_timeout_override":               types.Int64PointerValue(response.DynamicClientRegistration.PendingAuthorizationTimeoutOverride),
			"persistent_grant_expiration_time":                     types.Int64PointerValue(response.DynamicClientRegistration.PersistentGrantExpirationTime),
			"persistent_grant_expiration_time_unit":                types.StringPointerValue(response.DynamicClientRegistration.PersistentGrantExpirationTimeUnit),
			"persistent_grant_expiration_type":                     types.StringPointerValue(response.DynamicClientRegistration.PersistentGrantExpirationType),
			"persistent_grant_idle_timeout":                        types.Int64PointerValue(response.DynamicClientRegistration.PersistentGrantIdleTimeout),
			"persistent_grant_idle_timeout_time_unit":              types.StringPointerValue(response.DynamicClientRegistration.PersistentGrantIdleTimeoutTimeUnit),
			"persistent_grant_idle_timeout_type":                   types.StringPointerValue(response.DynamicClientRegistration.PersistentGrantIdleTimeoutType),
			"policy_refs":                                          dynamicClientRegistrationPolicyRefsValue,
			"refresh_rolling":                                      types.StringPointerValue(response.DynamicClientRegistration.RefreshRolling),
			"refresh_token_rolling_grace_period":                   types.Int64PointerValue(response.DynamicClientRegistration.RefreshTokenRollingGracePeriod),
			"refresh_token_rolling_grace_period_type":              types.StringValue(gracePeriodType),
			"refresh_token_rolling_interval":                       types.Int64PointerValue(response.DynamicClientRegistration.RefreshTokenRollingInterval),
			"refresh_token_rolling_interval_time_unit":             types.StringPointerValue(response.DynamicClientRegistration.RefreshTokenRollingIntervalTimeUnit),
			"refresh_token_rolling_interval_type":                  types.StringPointerValue(response.DynamicClientRegistration.RefreshTokenRollingIntervalType),
			"request_policy_ref":                                   dynamicClientRegistrationRequestPolicyRefValue,
			"require_jwt_secured_authorization_response_mode":      types.BoolPointerValue(response.DynamicClientRegistration.RequireJwtSecuredAuthorizationResponseMode),
			"require_offline_access_scope_to_issue_refresh_tokens": types.StringPointerValue(response.DynamicClientRegistration.RequireOfflineAccessScopeToIssueRefreshTokens),
			"require_proof_key_for_code_exchange":                  types.BoolPointerValue(response.DynamicClientRegistration.RequireProofKeyForCodeExchange),
			"require_signed_requests":                              types.BoolPointerValue(response.DynamicClientRegistration.RequireSignedRequests),
			"restrict_common_scopes":                               types.BoolPointerValue(response.DynamicClientRegistration.RestrictCommonScopes),
			"restrict_to_default_access_token_manager":             types.BoolPointerValue(response.DynamicClientRegistration.RestrictToDefaultAccessTokenManager),
			"restricted_common_scopes":                             dynamicClientRegistrationRestrictedCommonScopesValue,
			"retain_client_secret":                                 types.BoolPointerValue(response.DynamicClientRegistration.RetainClientSecret),
			"rotate_client_secret":                                 types.BoolPointerValue(response.DynamicClientRegistration.RotateClientSecret),
			"rotate_registration_access_token":                     types.BoolPointerValue(response.DynamicClientRegistration.RotateRegistrationAccessToken),
			"token_exchange_processor_policy_ref":                  dynamicClientRegistrationTokenExchangeProcessorPolicyRefValue,
			"user_authorization_url_override":                      types.StringPointerValue(response.DynamicClientRegistration.UserAuthorizationUrlOverride),
		})
		respDiags.Append(diags...)
	}

	state.DynamicClientRegistration = dynamicClientRegistrationValue
	return respDiags
}

// Set all non-primitive attributes to null with appropriate attribute types
func (r *oauthClientSettingsResource) emptyModel() oauthClientSettingsResourceModel {
	var model oauthClientSettingsResourceModel
	// dynamic_client_registration
	dynamicClientRegistrationClientCertIssuerRefAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	dynamicClientRegistrationDefaultAccessTokenManagerRefAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	dynamicClientRegistrationOidcPolicyPolicyGroupAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	dynamicClientRegistrationOidcPolicyAttrTypes := map[string]attr.Type{
		"id_token_content_encryption_algorithm": types.StringType,
		"id_token_encryption_algorithm":         types.StringType,
		"id_token_signing_algorithm":            types.StringType,
		"policy_group":                          types.ObjectType{AttrTypes: dynamicClientRegistrationOidcPolicyPolicyGroupAttrTypes},
	}
	dynamicClientRegistrationPolicyRefsAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	dynamicClientRegistrationPolicyRefsElementType := types.ObjectType{AttrTypes: dynamicClientRegistrationPolicyRefsAttrTypes}
	dynamicClientRegistrationRequestPolicyRefAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	dynamicClientRegistrationTokenExchangeProcessorPolicyRefAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	dynamicClientRegistrationAttrTypes := map[string]attr.Type{
		"allow_client_delete":                                  types.BoolType,
		"allowed_authorization_detail_types":                   types.SetType{ElemType: types.StringType},
		"allowed_exclusive_scopes":                             types.SetType{ElemType: types.StringType},
		"bypass_activation_code_confirmation_override":         types.BoolType,
		"ciba_polling_interval":                                types.Int64Type,
		"ciba_require_signed_requests":                         types.BoolType,
		"client_cert_issuer_ref":                               types.ObjectType{AttrTypes: dynamicClientRegistrationClientCertIssuerRefAttrTypes},
		"client_cert_issuer_type":                              types.StringType,
		"client_secret_retention_period_override":              types.Int64Type,
		"client_secret_retention_period_type":                  types.StringType,
		"default_access_token_manager_ref":                     types.ObjectType{AttrTypes: dynamicClientRegistrationDefaultAccessTokenManagerRefAttrTypes},
		"device_flow_setting_type":                             types.StringType,
		"device_polling_interval_override":                     types.Int64Type,
		"disable_registration_access_tokens":                   types.BoolType,
		"enforce_replay_prevention":                            types.BoolType,
		"initial_access_token_scope":                           types.StringType,
		"lockout_max_malicious_actions":                        types.Int64Type,
		"lockout_max_malicious_actions_type":                   types.StringType,
		"offline_access_require_consent_prompt":                types.StringType,
		"oidc_policy":                                          types.ObjectType{AttrTypes: dynamicClientRegistrationOidcPolicyAttrTypes},
		"pending_authorization_timeout_override":               types.Int64Type,
		"persistent_grant_expiration_time":                     types.Int64Type,
		"persistent_grant_expiration_time_unit":                types.StringType,
		"persistent_grant_expiration_type":                     types.StringType,
		"persistent_grant_idle_timeout":                        types.Int64Type,
		"persistent_grant_idle_timeout_time_unit":              types.StringType,
		"persistent_grant_idle_timeout_type":                   types.StringType,
		"policy_refs":                                          types.ListType{ElemType: dynamicClientRegistrationPolicyRefsElementType},
		"refresh_rolling":                                      types.StringType,
		"refresh_token_rolling_grace_period":                   types.Int64Type,
		"refresh_token_rolling_grace_period_type":              types.StringType,
		"refresh_token_rolling_interval":                       types.Int64Type,
		"refresh_token_rolling_interval_time_unit":             types.StringType,
		"refresh_token_rolling_interval_type":                  types.StringType,
		"request_policy_ref":                                   types.ObjectType{AttrTypes: dynamicClientRegistrationRequestPolicyRefAttrTypes},
		"require_jwt_secured_authorization_response_mode":      types.BoolType,
		"require_offline_access_scope_to_issue_refresh_tokens": types.StringType,
		"require_proof_key_for_code_exchange":                  types.BoolType,
		"require_signed_requests":                              types.BoolType,
		"restrict_common_scopes":                               types.BoolType,
		"restrict_to_default_access_token_manager":             types.BoolType,
		"restricted_common_scopes":                             types.SetType{ElemType: types.StringType},
		"retain_client_secret":                                 types.BoolType,
		"rotate_client_secret":                                 types.BoolType,
		"rotate_registration_access_token":                     types.BoolType,
		"token_exchange_processor_policy_ref":                  types.ObjectType{AttrTypes: dynamicClientRegistrationTokenExchangeProcessorPolicyRefAttrTypes},
		"user_authorization_url_override":                      types.StringType,
	}
	model.DynamicClientRegistration = types.ObjectNull(dynamicClientRegistrationAttrTypes)
	return model
}

func (r *oauthClientSettingsResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data oauthClientSettingsResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// This resource depends on the values in the /extendedProperties endpoint, so pass those in to build the client struct
	apiReadExtendedProperties, httpResp, err := r.apiClient.ExtendedPropertiesAPI.GetExtendedProperties(config.AuthContext(ctx, r.providerConfig)).Execute()
	if err != nil {
		config.ReportHttpError(ctx, &resp.Diagnostics, "An error occurred while getting the extended properties", err, httpResp)
		return
	}

	// Update API call logic, since this is a singleton resource
	clientData, diags := data.buildClientStruct(apiReadExtendedProperties.Items)
	resp.Diagnostics.Append(diags...)
	apiUpdateRequest := r.apiClient.OauthClientSettingsAPI.UpdateOauthClientSettings(config.AuthContext(ctx, r.providerConfig))
	apiUpdateRequest = apiUpdateRequest.Body(*clientData)
	responseData, httpResp, err := r.apiClient.OauthClientSettingsAPI.UpdateOauthClientSettingsExecute(apiUpdateRequest)
	if err != nil {
		config.ReportHttpError(ctx, &resp.Diagnostics, "An error occurred while creating the oauthClientSettings", err, httpResp)
		return
	}

	// Read response into the model
	resp.Diagnostics.Append(data.readClientResponseCheckPfIgnoredAttrs(responseData, true)...)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *oauthClientSettingsResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data oauthClientSettingsResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Read API call logic
	responseData, httpResp, err := r.apiClient.OauthClientSettingsAPI.GetOauthClientSettings(config.AuthContext(ctx, r.providerConfig)).Execute()
	if err != nil {
		if httpResp != nil && httpResp.StatusCode == 404 {
			config.AddResourceNotFoundWarning(ctx, &resp.Diagnostics, "OAuth Client Settings", httpResp)
			resp.State.RemoveResource(ctx)
		} else {
			config.ReportHttpError(ctx, &resp.Diagnostics, "An error occurred while reading the oauthClientSettings", err, httpResp)
		}
		return
	}

	// Read response into the model
	resp.Diagnostics.Append(data.readClientResponseCheckPfIgnoredAttrs(responseData, false)...)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *oauthClientSettingsResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data oauthClientSettingsResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// This resource depends on the values in the /extendedProperties endpoint, so pass those in to build the client struct
	apiReadExtendedProperties, httpResp, err := r.apiClient.ExtendedPropertiesAPI.GetExtendedProperties(config.AuthContext(ctx, r.providerConfig)).Execute()
	if err != nil {
		config.ReportHttpError(ctx, &resp.Diagnostics, "An error occurred while getting the extended properties", err, httpResp)
		return
	}

	// Update API call logic
	clientData, diags := data.buildClientStruct(apiReadExtendedProperties.Items)
	resp.Diagnostics.Append(diags...)
	apiUpdateRequest := r.apiClient.OauthClientSettingsAPI.UpdateOauthClientSettings(config.AuthContext(ctx, r.providerConfig))
	apiUpdateRequest = apiUpdateRequest.Body(*clientData)
	responseData, httpResp, err := r.apiClient.OauthClientSettingsAPI.UpdateOauthClientSettingsExecute(apiUpdateRequest)
	if err != nil {
		config.ReportHttpError(ctx, &resp.Diagnostics, "An error occurred while updating the oauthClientSettings", err, httpResp)
		return
	}

	// Read response into the model
	resp.Diagnostics.Append(data.readClientResponseCheckPfIgnoredAttrs(responseData, true)...)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *oauthClientSettingsResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// This resource has no identifier attributes, so the value passed in here doesn't matter. Just return an empty state struct.
	emptyState := r.emptyModel()
	resp.Diagnostics.Append(resp.State.Set(ctx, &emptyState)...)
}
