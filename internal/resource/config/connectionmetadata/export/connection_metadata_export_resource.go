// Code generated by ping-terraform-plugin-framework-generator

package connectionmetadataexport

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	client "github.com/pingidentity/pingfederate-go-client/v1210/configurationapi"
	"github.com/pingidentity/terraform-provider-pingfederate/internal/resource/config"
	internaltypes "github.com/pingidentity/terraform-provider-pingfederate/internal/types"
)

var (
	_ resource.Resource              = &connectionMetadataExportResource{}
	_ resource.ResourceWithConfigure = &connectionMetadataExportResource{}
)

func ConnectionMetadataExportResource() resource.Resource {
	return &connectionMetadataExportResource{}
}

type connectionMetadataExportResource struct {
	providerConfig internaltypes.ProviderConfiguration
	apiClient      *client.APIClient
}

func (r *connectionMetadataExportResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_connection_metadata_export"
}

func (r *connectionMetadataExportResource) Configure(_ context.Context, req resource.ConfigureRequest, _ *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerCfg := req.ProviderData.(internaltypes.ResourceConfiguration)
	r.providerConfig = providerCfg.ProviderConfig
	r.apiClient = providerCfg.ApiClient
}

type connectionMetadataResourceModel struct {
	ConnectionType             types.String `tfsdk:"connection_type"`
	ConnectionId               types.String `tfsdk:"connection_id"`
	VirtualServerId            types.String `tfsdk:"virtual_server_id"`
	SigningSettings            types.Object `tfsdk:"signing_settings"`
	UseSecondaryPortForSoap    types.Bool   `tfsdk:"use_secondary_port_for_soap"`
	VirtualHostName            types.String `tfsdk:"virtual_host_name"`
	ExportedConnectionMetadata types.String `tfsdk:"exported_connection_metadata"`
}

func (r *connectionMetadataExportResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Resource to export a connection's SAML metadata that can be given to a partner.",
		Attributes: map[string]schema.Attribute{
			"connection_type": schema.StringAttribute{
				Description: "The type of connection to export. Options are `IDP` or `SP`. This field is immutable and will trigger a replacement plan if changed.",
				Required:    true,
				Validators: []validator.String{
					stringvalidator.OneOf("IDP", "SP"),
				},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"connection_id": schema.StringAttribute{
				Description: "The ID of the connection to export. This field is immutable and will trigger a replacement plan if changed.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1),
				},
			},
			"virtual_server_id": schema.StringAttribute{
				Description: "The virtual server ID to export the metadata with. If `null`, the connection's default will be used. This field is immutable and will trigger a replacement plan if changed.",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"signing_settings": schema.SingleNestedAttribute{
				Description: "The signing settings to sign the metadata with. If `null`, the metadata will not be signed. This field is immutable and will trigger a replacement plan if changed.",
				Optional:    true,
				Attributes: map[string]schema.Attribute{
					"signing_key_pair_ref": schema.SingleNestedAttribute{
						Description: "The ID of the key pair used to sign messages sent to this partner. The ID of the key pair is also known as the alias and can be found by viewing the corresponding certificate under 'Signing & Decryption Keys & Certificates' in the PingFederate admin console. This field is immutable and will trigger a replacement plan if changed.",
						Required:    true,
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Description: "The ID of the resource.",
								Required:    true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplace(),
								},
								Validators: []validator.String{
									stringvalidator.LengthAtLeast(1),
								},
							},
						},
					},
					"algorithm": schema.StringAttribute{
						Description: "The algorithm used to sign messages sent to this partner. The default is `SHA1withDSA` for DSA certs, `SHA256withRSA` for RSA certs, and `SHA256withECDSA` for EC certs. For RSA certs, `SHA1withRSA`, `SHA384withRSA`, `SHA512withRSA`, `SHA256withRSAandMGF1`, `SHA384withRSAandMGF1` and `SHA512withRSAandMGF1` are also supported. For EC certs, `SHA384withECDSA` and `SHA512withECDSA` are also supported. If the connection is WS-Federation with JWT token type, then the possible values are `RSA SHA256`, `RSA SHA384`, `RSA SHA512`, `RSASSA-PSS SHA256`, `RSASSA-PSS SHA384`, `RSASSA-PSS SHA512`, `ECDSA SHA256`, `ECDSA SHA384`, `ECDSA SHA512`. This field is immutable and will trigger a replacement plan if changed.",
						Optional:    true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
						Validators: []validator.String{
							stringvalidator.LengthAtLeast(1),
						},
					},
					"include_cert_in_signature": schema.BoolAttribute{
						Description: "Determines whether the signing certificate is included in the signature element. This field is immutable and will trigger a replacement plan if changed.",
						Optional:    true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplace(),
						},
					},
					"include_raw_key_in_signature": schema.BoolAttribute{
						Description: "Determines whether the element with the raw public key is included in the signature element. This field is immutable and will trigger a replacement plan if changed.",
						Optional:    true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"use_secondary_port_for_soap": schema.BoolAttribute{
				Description: "If PingFederate's secondary SSL port is configured and you want to use it for the SOAP channel, set to `true`. If client-certificate authentication is configured for the SOAP channel, the secondary port is required and this must be set to `true`. This field is immutable and will trigger a replacement plan if changed.",
				Optional:    true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},
			},
			"virtual_host_name": schema.StringAttribute{
				Description: "The virtual host name to be used as the base url. This field is immutable and will trigger a replacement plan if changed.",
				Optional:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1),
				},
			},
			"exported_connection_metadata": schema.StringAttribute{
				Description: "The exported SAML metadata.",
				Computed:    true,
			},
		},
	}
}

func (model *connectionMetadataResourceModel) buildClientStruct() *client.ExportMetadataRequest {
	result := &client.ExportMetadataRequest{}

	result.ConnectionId = model.ConnectionId.ValueString()
	result.ConnectionType = model.ConnectionType.ValueString()
	result.VirtualServerId = model.VirtualServerId.ValueStringPointer()
	result.UseSecondaryPortForSoap = model.UseSecondaryPortForSoap.ValueBoolPointer()
	result.VirtualHostName = model.VirtualHostName.ValueStringPointer()

	if internaltypes.IsDefined(model.SigningSettings) {
		signingSettingsAttrs := model.SigningSettings.Attributes()
		signingKeyPairRefAttrs := signingSettingsAttrs["signing_key_pair_ref"].(types.Object).Attributes()
		result.SigningSettings = &client.BaseSigningSettings{
			SigningKeyPairRef: client.ResourceLink{
				Id: signingKeyPairRefAttrs["id"].(types.String).ValueString(),
			},
			Algorithm:                signingSettingsAttrs["algorithm"].(types.String).ValueStringPointer(),
			IncludeCertInSignature:   signingSettingsAttrs["include_cert_in_signature"].(types.Bool).ValueBoolPointer(),
			IncludeRawKeyInSignature: signingSettingsAttrs["include_raw_key_in_signature"].(types.Bool).ValueBoolPointer(),
		}
	}

	return result
}

func (r *connectionMetadataExportResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data connectionMetadataResourceModel

	// Read Terraform config data into the model
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Read API call logic
	exportRequestBody := data.buildClientStruct()
	exportRequest := r.apiClient.ConnectionMetadataAPI.Export(config.AuthContext(ctx, r.providerConfig)).Body(*exportRequestBody)
	responseData, httpResp, err := exportRequest.Execute()
	if err != nil {
		config.ReportHttpError(ctx, &resp.Diagnostics, "An error occurred while exporting the connection metadata", err, httpResp)
		return
	}

	// Set the exported metadata
	data.ExportedConnectionMetadata = types.StringValue(responseData)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *connectionMetadataExportResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	// To avoid re-exporting the connection metadata on every plan, we'll just maintain whatever is in state
	resp.State.Raw = req.State.Raw
}

func (r *connectionMetadataExportResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	// This method won't be called since all non-computed attributes require replacement
}

func (r *connectionMetadataExportResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	// This doesn't represent a real resource in PF, so nothing to do here
}
