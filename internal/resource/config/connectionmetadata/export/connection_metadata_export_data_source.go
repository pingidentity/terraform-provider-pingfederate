// Code generated by ping-terraform-plugin-framework-generator

package connectionmetadataexport

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	client "github.com/pingidentity/pingfederate-go-client/v1210/configurationapi"
	"github.com/pingidentity/terraform-provider-pingfederate/internal/resource/config"
	internaltypes "github.com/pingidentity/terraform-provider-pingfederate/internal/types"
)

var (
	_ datasource.DataSource              = &connectionMetadataExportDataSource{}
	_ datasource.DataSourceWithConfigure = &connectionMetadataExportDataSource{}
)

func ConnectionMetadataExportDataSource() datasource.DataSource {
	return &connectionMetadataExportDataSource{}
}

type connectionMetadataExportDataSource struct {
	providerConfig internaltypes.ProviderConfiguration
	apiClient      *client.APIClient
}

func (r *connectionMetadataExportDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_connection_metadata_export"
}

func (r *connectionMetadataExportDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, _ *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerCfg := req.ProviderData.(internaltypes.ResourceConfiguration)
	r.providerConfig = providerCfg.ProviderConfig
	r.apiClient = providerCfg.ApiClient
}

type connectionMetadataDataSourceModel struct {
	ConnectionType             types.String `tfsdk:"connection_type"`
	ConnectionId               types.String `tfsdk:"connection_id"`
	VirtualServerId            types.String `tfsdk:"virtual_server_id"`
	SigningSettings            types.Object `tfsdk:"signing_settings"`
	UseSecondaryPortForSoap    types.Bool   `tfsdk:"use_secondary_port_for_soap"`
	VirtualHostName            types.String `tfsdk:"virtual_host_name"`
	ExportedConnectionMetadata types.String `tfsdk:"exported_connection_metadata"`
}

func (r *connectionMetadataExportDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Datasource to export a connection's SAML metadata that can be given to a partner.",
		Attributes: map[string]schema.Attribute{
			"connection_type": schema.StringAttribute{
				Description: "The type of connection to export. Options are `IDP` or `SP`.",
				Required:    true,
				Validators: []validator.String{
					stringvalidator.OneOf("IDP", "SP"),
				},
			},
			"connection_id": schema.StringAttribute{
				Description: "The ID of the connection to export.",
				Required:    true,
			},
			"virtual_server_id": schema.StringAttribute{
				Description: "The virtual server ID to export the metadata with. If `null`, the connection's default will be used.",
				Optional:    true,
			},
			"signing_settings": schema.SingleNestedAttribute{
				Description: "The signing settings to sign the metadata with. If `null`, the metadata will not be signed",
				Optional:    true,
				Attributes: map[string]schema.Attribute{
					"signing_key_pair_ref": schema.SingleNestedAttribute{
						Description: "The ID of the key pair used to sign messages sent to this partner. The ID of the key pair is also known as the alias and can be found by viewing the corresponding certificate under 'Signing & Decryption Keys & Certificates' in the PingFederate admin console.",
						Required:    true,
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Description: "The ID of the resource.",
								Required:    true,
							},
						},
					},
					"algorithm": schema.StringAttribute{
						Description: "The algorithm used to sign messages sent to this partner. The default is `SHA1withDSA` for DSA certs, `SHA256withRSA` for RSA certs, and `SHA256withECDSA` for EC certs. For RSA certs, `SHA1withRSA`, `SHA384withRSA`, `SHA512withRSA`, `SHA256withRSAandMGF1`, `SHA384withRSAandMGF1` and `SHA512withRSAandMGF1` are also supported. For EC certs, `SHA384withECDSA` and `SHA512withECDSA` are also supported. If the connection is WS-Federation with JWT token type, then the possible values are `RSA SHA256`, `RSA SHA384`, `RSA SHA512`, `RSASSA-PSS SHA256`, `RSASSA-PSS SHA384`, `RSASSA-PSS SHA512`, `ECDSA SHA256`, `ECDSA SHA384`, `ECDSA SHA512`",
						Optional:    true,
					},
					"include_cert_in_signature": schema.BoolAttribute{
						Description: "Determines whether the signing certificate is included in the signature element.",
						Optional:    true,
					},
					"include_raw_key_in_signature": schema.BoolAttribute{
						Description: "Determines whether the element with the raw public key is included in the signature element.",
						Optional:    true,
					},
				},
			},
			"use_secondary_port_for_soap": schema.BoolAttribute{
				Description: "If PingFederate's secondary SSL port is configured and you want to use it for the SOAP channel, set to true. If client-certificate authentication is configured for the SOAP channel, the secondary port is required and this must be set to `true`.",
				Optional:    true,
			},
			"virtual_host_name": schema.StringAttribute{
				Description: "The virtual host name to be used as the base url.",
				Optional:    true,
			},
			"exported_connection_metadata": schema.StringAttribute{
				Description: "The exported SAML metadata.",
				Optional:    false,
				Computed:    true,
			},
		},
	}
}

func (model *connectionMetadataDataSourceModel) buildClientStruct() *client.ExportMetadataRequest {
	result := &client.ExportMetadataRequest{}

	result.ConnectionId = model.ConnectionId.ValueString()
	result.ConnectionType = model.ConnectionType.ValueString()
	result.VirtualServerId = model.VirtualServerId.ValueStringPointer()
	result.UseSecondaryPortForSoap = model.UseSecondaryPortForSoap.ValueBoolPointer()
	result.VirtualHostName = model.VirtualHostName.ValueStringPointer()

	if internaltypes.IsDefined(model.SigningSettings) {
		signingSettingsAttrs := model.SigningSettings.Attributes()
		signingKeyPairRefAttrs := signingSettingsAttrs["signing_key_pair_ref"].(types.Object).Attributes()
		result.SigningSettings = &client.BaseSigningSettings{
			SigningKeyPairRef: client.ResourceLink{
				Id: signingKeyPairRefAttrs["id"].(types.String).ValueString(),
			},
			Algorithm:                signingSettingsAttrs["algorithm"].(types.String).ValueStringPointer(),
			IncludeCertInSignature:   signingSettingsAttrs["include_cert_in_signature"].(types.Bool).ValueBoolPointer(),
			IncludeRawKeyInSignature: signingSettingsAttrs["include_raw_key_in_signature"].(types.Bool).ValueBoolPointer(),
		}
	}

	return result
}

func (r *connectionMetadataExportDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data connectionMetadataDataSourceModel

	// Read Terraform config data into the model
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Read API call logic
	exportRequestBody := data.buildClientStruct()
	exportRequest := r.apiClient.ConnectionMetadataAPI.Export(config.AuthContext(ctx, r.providerConfig)).Body(*exportRequestBody)
	responseData, httpResp, err := exportRequest.Execute()
	if err != nil {
		config.ReportHttpError(ctx, &resp.Diagnostics, "An error occurred while exporting the connection metadata", err, httpResp)
		return
	}

	// Set the exported metadata
	data.ExportedConnectionMetadata = types.StringValue(responseData)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
