// Code generated by ping-terraform-plugin-framework-generator

package configstore

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	client "github.com/pingidentity/pingfederate-go-client/v1210/configurationapi"
	"github.com/pingidentity/terraform-provider-pingfederate/internal/resource/config"
	internaltypes "github.com/pingidentity/terraform-provider-pingfederate/internal/types"
)

var (
	_ datasource.DataSource              = &configStoreDataSource{}
	_ datasource.DataSourceWithConfigure = &configStoreDataSource{}
)

func ConfigStoreDataSource() datasource.DataSource {
	return &configStoreDataSource{}
}

type configStoreDataSource struct {
	providerConfig internaltypes.ProviderConfiguration
	apiClient      *client.APIClient
}

func (r *configStoreDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_config_store"
}

func (r *configStoreDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, _ *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerCfg := req.ProviderData.(internaltypes.ResourceConfiguration)
	r.providerConfig = providerCfg.ProviderConfig
	r.apiClient = providerCfg.ApiClient
}

type configStoreDataSourceModel struct {
	Bundle types.String `tfsdk:"bundle"`
	Items  types.List   `tfsdk:"items"`
}

func (r *configStoreDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Data source to retrieve a bundle of settings.",
		Attributes: map[string]schema.Attribute{
			"bundle": schema.StringAttribute{
				Required:    true,
				Description: "This field represents a configuration file that contains a bundle of settings.",
			},
			"items": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Computed:    true,
							Description: "The id of the configuration setting.",
						},
						"list_value": schema.ListAttribute{
							ElementType: types.StringType,
							Computed:    true,
							Description: "The list of values for the configuration setting. This is used when the setting has a list of string values.",
						},
						"map_value": schema.MapAttribute{
							ElementType: types.StringType,
							Computed:    true,
							Description: "The map of key/value pairs for the configuration setting. This is used when the setting has a map of string keys and values.",
						},
						"string_value": schema.StringAttribute{
							Computed:    true,
							Description: "The value of the configuration setting. This is used when the setting has a single string value.",
						},
						"type": schema.StringAttribute{
							Computed:    true,
							Description: "The type of configuration setting. This could be a single string, list of strings, or map of string keys and values.",
						},
					},
				},
				Computed:    true,
				Description: "List of configuration settings.",
			},
		},
	}
}

func (state *configStoreDataSourceModel) readClientResponse(response *client.ConfigStoreBundle) diag.Diagnostics {
	var respDiags, diags diag.Diagnostics
	// items
	itemsAttrTypes := map[string]attr.Type{
		"id":           types.StringType,
		"list_value":   types.ListType{ElemType: types.StringType},
		"map_value":    types.MapType{ElemType: types.StringType},
		"string_value": types.StringType,
		"type":         types.StringType,
	}
	itemsElementType := types.ObjectType{AttrTypes: itemsAttrTypes}
	var itemsValues []attr.Value
	for _, itemsResponseValue := range response.Items {
		itemsListValueValue, diags := types.ListValueFrom(context.Background(), types.StringType, itemsResponseValue.ListValue)
		respDiags.Append(diags...)
		var itemsMapValueValue types.Map
		if itemsResponseValue.MapValue == nil {
			itemsMapValueValue = types.MapNull(types.StringType)
		} else {
			itemsMapValueValue, diags = types.MapValueFrom(context.Background(), types.StringType, (*itemsResponseValue.MapValue))
			respDiags.Append(diags...)
		}
		itemsValue, diags := types.ObjectValue(itemsAttrTypes, map[string]attr.Value{
			"id":           types.StringValue(itemsResponseValue.Id),
			"list_value":   itemsListValueValue,
			"map_value":    itemsMapValueValue,
			"string_value": types.StringPointerValue(itemsResponseValue.StringValue),
			"type":         types.StringValue(itemsResponseValue.Type),
		})
		respDiags.Append(diags...)
		itemsValues = append(itemsValues, itemsValue)
	}
	itemsValue, diags := types.ListValue(itemsElementType, itemsValues)
	respDiags.Append(diags...)

	state.Items = itemsValue
	return respDiags
}

func (r *configStoreDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data configStoreDataSourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Read API call logic
	responseData, httpResp, err := r.apiClient.ConfigStoreAPI.GetConfigStoreSettings(config.AuthContext(ctx, r.providerConfig), data.Bundle.ValueString()).Execute()
	if err != nil {
		config.ReportHttpError(ctx, &resp.Diagnostics, "An error occurred while reading the configStore", err, httpResp)
		return
	}

	// Read response into the model
	resp.Diagnostics.Append(data.readClientResponse(responseData)...)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
